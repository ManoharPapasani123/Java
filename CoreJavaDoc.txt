Platform 
--------
*A platform is an environment where we can execute different programs.

ex:
  os(windows,linux,unix etc)
  technology(java,.net etc)

Platform Dependent
------------------
*If application of one operating system cannot be executed on other operating system such kind of application is called as platform dependent.
ex:
 c/c++ Applications

Platform Independent
--------------------
If  application of one os can be executed on other os such kind of applications are called platform independent.
ex:
Java applications


History of java
---------------
*In early 1990's sunmicrosystems was developing a software for electronic devices.


*At that time c/c++ are the most powerful languages but they are platform dependent.

*so sunmicrosystems started to develop a new programming language which is platform independent under the guidance of James Gosling.

*The name of the project is Green Project.

*By 1992 they had developed a platform independent language.

*Initially it is named as oak 

*In 1995 oak is renamed to java due to patent issue.



Features of java
----------------
0)opensource
1)Platform independent.
2)oop[Object oriented programming]
3)Portable
4)simple
5)Interpreted.
6)robust and secured
7)distributed
8)Multithreaded.

Execution Process c and cpp program
-----------------------------------
*if we develop any program it has to undergo 2 phases

i)compilation
ii)execution

if we compile a c/cpp program we get an intermediate code called as .obj file.

*we execute or convert .obj into .exe using a program called Linker.

*.exe is when executed provides output.


Here either .obj or .exe of one os cannot be executed on other os,so c/cpp are platform dependent.


.c/.cpp-->compile-->.obj-->Linker-->.exe



Execution Process of a java program
-----------------------------------

.java--->comiple-->.class[bytecode]--->Jvm-->o/p
                                       Jit

*we save a java program using the extension .java

*Execution of a java program undergoes 2 phases

i)compilation
ii)execution

i)compilation

*if we compile a .java program we get .class[bytecode]

.java-->compiled-->.class[bytecode]

*once we get a .class again we should convert bytecode to machine code using jvm[java virtual machine]

*Jvm is a program which helps in converting bc to mc

.class-->jvm-->o/p

*.class is platform independent code,we can execute the .class file of one os on another os.

*.class is interpreted by jvm so jvm is also called as bytecode interpretor.

*jvm is platform dependent bcoz every os should have a seperate jvm.

what is JIT compiler?

It is a helper application of jvm which helps jvm to convert byte code to mahcine code together.



.java-->compile-->.class-->jvm-->o/p. 


Features  of java
-----------------
0)opensource:
    java is open source ,we can use java s/w for free of cost.

i)Platform independent
----------------------
*java is platform independent because we can execute .class[bytecode] of one os on any other os.

2)Object Oreinted
-----------------
Java is object oriented because it consists of objects and classes.

3)Portable
----------
*Bothe java s/w and java bytecode can be executed on different os's so java is portable.


4)simple
--------
Java is developed from c and c++,so learning java is simple.

5)robust[strong)
---------------
*Java programs do not crash easily because of exception handling mechanism so java is robust.

6)interpreted
--------------
As jvm interprets bytecode to machine code,java is called interpreted language.

7)secured
---------
Java is secured because virus don't attack .class files,also java is robust.

*No pointers in java.

*Java has both comiple time checks and run time checks

8)distributed
--------------
we can run java programs on different os's so we can say java is distributed.

9)Multithreaded
--------------- 
Thread
------
*Thread is an independent part of a program and a light weight process.

*Multithreading is group of threads executing parallely to accomplish a task.


Language fundamentals
---------------------
1)variables
2)keywords
3)constants
4)datatypes
5)operators


variable
--------
*Variable is an identifier which identifies a value,whose value changes.

syntax
------
datatype variablename;

ex:
 int a;


Rules for declaring variables
-----------------------------
*A variable should start with alphabet or underscore or dollar ,after that we can use numbers in a variable.

*No special symbols are allowed in a variable except underscore(_) and dollar($)

*No  spaces are allowed in a variable.


ex:
a(v)
b(v)
abc123(v)
123abc(IV)
a_bc_c(v)
a+b+c(iv)
a bc(iv)
s_(v)
_$(v)
$123(v)
%@abc(iv)
$(v)
_(v)
abc 123(iv)


Keywords
--------
*keywords are builtin or predefined words.

*There are around 53 keywords in  java

ex:
int 
char
float 
double 
long
while
do 
for 
class
etc

Rules for declaring keywords
----------------------------
i)A keyword must be declared in lowercase.

ii)we cannot use keywords as identifiers.


ex:

INT(ic)
Float(ic)
while(c)

int int;(iv)

int x;(c)


Constants
---------
Constant is a fixed value.

There are 3 types of constants.
i)character
ii)Numeric
iii)boolean



character constants
-------------------
character constants are 

i)words.
ii)alphabets[a-z,A-Z].
iii)digits[0-9].
iv)special symbols.

character constants are of 2 types.

i)single character constants
ii)String constants.

i)single chracter constant
--------------------------
single character enclosed in single quotes is known as 
single character constant.

ex:
  'a'
  'x'
  '5'
  '*'
  ''
   '10'(ic)
   'abc'(ic)

String constants
----------------
group of letters enclosed in double quotes is known as 
string constant.

ex:
   "satya"
   "satya123"
   ""
   " "
   "a"
   "12345"
   

Numeric constants
-----------------
All numbers are numeric constants

They are 2 types 

Integer constant

decimal/real/floating-point constant.

Integer constant
----------------
Number without fractional part is called integer constant.

ex:
10
20 
56

decimal constant.
-----------------
Number with fractional part is called decimal constant.

ex:10.7 
5.6


we can represent integer constant  in the following number systems.

i)Decimal(regular)
ii)binary
iii)octal
iv)hexa decimal system 

decimal number system
---------------------
It has base as 10 i,e it consists base numbers from 0 to 9

ex:19
   20
   1
   158


Binary number system
--------------------
It has base as 2 i,e it consists of digits 0 or 1.

ex:010
   110
   etc


converting decimal to binary
----------------------------
if we want to convert decimal number to binary we should perform lcm using 2.

536   --> ?
  10      2 

2|536
  ---
2|268-0
  ---
2|134-0
  ---
2|67-0
  --
2|33-1 
  ----
2|16-1
  ----
2|8-0
  ---
2|4-0
  --
2|2-0
 ----
2|1-0
  ---
2|0-1



collect  remainders from bottom to top

536-->1000011000

converting binary to decimal
----------------------------
1    0   0   0    0     1   1    0    0    0
2^9 2^8 2^7  2^6  2^5  2^4  2^3  2^2  2^1  2^0


2^9*1+2^8*0+..........+2^0*0.

512+0+.......+0

536

octal number system
-------------------
It has a base as 8 i'e  it has digits from 0 to 7.

Always an octal integer must have a prefix 0[zero].

ex:
   0123(v)

   012(v)
   123(iv)
   078(iv)

converting decimal to octal
---------------------------
36--> ?
10   8


8|36
  --
8|4-4
  ---
8|0-4

octal-->044

converting octal to decimal
---------------------------
044--> ? 
      10

0   4    4
8^2 8^1  8^0


0+32+4-->36


Hexa decimal system
-------------------
It has base as 16 i'e it consists altogether digits from 0 to 15

0 to 9[digits]
 
from 10-15 we should substitute alphabets a-f


10->a or A
11->b or B
12->c or C
13->d or D
14->e or E
15->f or F 


It should have a prefix 0x or 0X


ex:
0x123
0xabc
0xface

etc

converting decimal to hexa decimal

16|90 
   --
16|5-10
   ----
16|0-5


ans->0x5A




How many  number systems?
decimal has a base-----
binary has a bas-----
octal has a base-----
hexa decimal has a base----
ocatl has a prefix 0x.
hexa has a prefix 0x
binary has a prefix-----

Integer constants


By default integer constant is of----type


Boolean constants
-----------------
If a condition is evaluated it may either return true or false based on input by user

here the boolean constants are true/false

we must declare boolean constants in lowercase because both are predefined literals.

datatype
--------
datatype is keyword which tells about type of data we are using in a program.

datatype also allocates memory for a variable.


syntax
------
datatype varname;
 or
datatype var1,var2,....;
ex:
char cha;



variable declaration and initialization
---------------------------------------
we can declare and initialize a variable as shown below,

type1
-----
datatype var=value;

ex:
char ch='4';


type2
-----
datatype varname;

varname=value;

ex:

char ch;

ch='4';


declare and initialize character variable

char x='a';


declare and initialize byte variable

byte x=10;

declare and initialize short variable

short x=20;

declare and initialize int variable

int x=40;

declare and initialize long variable

long x=50;

declare and initialize float variable

float x=10.5f;

declare and initialize double variable

double x=10.5;

declare and initialize boolean variable

boolean x=true;

declare and initialize String variable

String x="manohar";


what is a variable?
variable syntax.
variable rules
   A variable should start with ---/---/---
   variables should not have ----- and -----
   keywords must declared in -------.
   keywords must not be declared as -------
   
what is datatype?
How many datatypes?
datatype types?
----is a reference type.




      






decimal literals
-----------------
*by default a decimal literal is of double type


*we should suffix a decimal literal with f/F while initializing it with a float variable.

*Java is very strict with type conversion,(however we can convert small datatype to big datatype but reverse is not possible automatically.)

* we cannot declare decimal literals as ocatal/hexadecimal ,vialation leads to compilation error.


*we can suffix a decimal literal with d/D while initializing to a double variable but it is optional.
ex:
float f=5.6;
double d=5.6;
double d=5.6D;
float f=10.5f;
double d=0123.456;
double d=0X123.456;
double d=0123;
double d=10;
float f=345;

Note:
we can suffix a long explicitly with l/L.

long l=10L;
long l=10l;


character literals
------------------
single letter enclosed in single quotes is known as single character constants.

we can represent single character constants in 2 ways in java

i)regular
ii)unicode

regular
-------
ex:
'a'
'5'
etc


unicode
-------
It is a 4 digit hexa decimal representation of a character.

syntax
------
'\uxxxx'

ex:
'\u0065'
'\u00be'
'\uface'
'\Ubeer'

*The only unsigned datatype in java is char

*unsigned datatype accpets only positive values.

*singned datatype accepts both  negative and positive values.

which of the following declarations are valid?



Note:
  we can also initialize integer lietrals to char variable.


Program structure of java
-------------------------
package declaration;
import statements;
class ClassName
{

   public static void main(String args[]){
    
    ....;
    ....;
   }
}
   

How to save a java program
--------------------------
ClassName.java/filename.java

How to compile a java program
-----------------------------
javac ClassName.java/filename.java

How to execute a java program
-----------------------------
java ClassName/filename

Naming conventions in java
--------------------------
A ClassName/interfacename/enumNam, every word starting letter must be uppercase

ex:
    CarTest
    SoftwareEngineer

A variable/methodname must start with lowercase and every inner word starting letter must be uppercase.

ex:
     nextLine()
     empName

A keyword/package must be declared in lowercase

ex:
     int 
     while
     pack1
     etc


Installing jdk 
--------------
we can download jdk from "oracle.com"

when we install a jdk we get 2 folders 

1)jdk
2)jre



Jdk[java development kit]
-------------------------
It consists of development tools[java,javac,javah,javap etc] and jre

jdk=development tools+jre

Jre[java runtime environment]
-----------------------------
It consists of jvm and runtime libraries

jre=jvm+runtime libraries.


once  jdk installation set classpath and path

path:It is system environment variable used to locate executable files from local file system.

How to set path
---------------
Goto-->c:/-->program files-->java-->jdk-->bin

copy the path from the address bar

C:\Program Files\Java\jdk1.8.0_111\bin

Now goto mycomputer-->right click-->properties-->advanced system settings->environment variables-->Under user variables

click on New-->variablename--path
               variable value--
C:\Program Files\Java\jdk1.8.0_111\bin


classpath:It is a java environment variable which is used to locate .class files of java.

How to set classpath
---------------
Goto-->c:/-->program files-->java-->jdk-->bin

copy the path from the address bar

                        C:\Program Files\Java\jre1.8.0_111\lib\rt.jar

Now goto mycomputer-->right click-->properties-->advanced system settings->environment variables-->Under user variables

click on New-->variablename--classpath
               variable value--
                        C:\Program Files\Java\jre1.8.0_111\lib\rt.jar

               
Note:open command prompt-->type the commands 

c:/>javac

Here we should find some summary

c:/>java

Here also we should find some summary.

Operator
--------
An operator is a symbol which performs an operation

1)Arithmetic operators
2)relational operators
3)logical operators
4)Assignment operators
5)unary operators
6)ternary operators
7)bitwise operators
8)concatenation operators
9)[]-index operator
9)instanceof
10)new 
11).(member access operator)


Arithmetic
-----------
+
-
*
%--remainder
/--quotient

ex:

int a=10,b=5,c;
c=a%b;-->0(remainder)
c=a/b;-->2(quotient)



relational 
----------
compares values

>--greater than
<--less than
>=--greater than or equal
<=--less than or equal
==--equal
!=--not equal

ex:
  int a=10,b=20;

   a>b--false


Note:Any relational operation returns a boolean value i,e either true/false.

Logical operators
-----------------
These are used to combine 2 or more statements

They are
i)logical and--&&
ii)logical or--||
iii)logical not--!

logical and--&&
---------------
It is used to combine 2 or more conditions but the expression returns true if every condition is true otherwise false.

ex:
    int s1=40,s2=50
  
    s1>=40&&s2>=40-->true

logical or--||
---------------
It is used to combine 2 or more conditions but the expression returns true if any one  condition is true or every condition is true,otherwise if all the condition's all false then or is false.

ex:
    int s1=40,s2=30
    s1>=40||s2>=40-->true

ex:
    true&&true-->true
    true&&false-->false
    true||true-->true
    false||false-->false
    false&&false-->false
    false&&true-->false
    false||true-->true
    true||false-->true



     true&&true&&false&&true||true-->true


logical not(!)
--------------
It is used as a negation

syntax
------

   !(expression)

   ex:
   !(true)-->false
    
   int a=10,b=7;
   
   !(a>b) -->false


Assignment operator
-------------------
An assignment operator assigns a value to a variable.

syntax
------
datatype varname=value;

ex:
  int a=10;

unary operators
---------------
An expression is collection operands and operators

ex:
a+b+c

operand
-------
An operand can be a variable or an expression.

Def:
  An operator applied on a single operand is known as unary operator.

we have 2 unary operators

i)incrementation(++)
ii)decrementation(--)

incrementation(++)
------------------
++ increments the value of an operand by 1

syntax
------
    (expression)++;

ex:
   int a=10;
   Sop(a);//10
   a++;
   Sop(a);//11

Forms of incrementation
-----------------------
a++-->post inc
++a-->pre inc
a=a+1-->expanded form
a+=1-->short hand

post inc:
    In this first  initialization is done  and then incremented.

ex:
   int a=10;
   b=a++;
   a=11  b=10

Here first the value of a is assigned/initialized to b and then a gets incremented.

pre inc:
    In this first  incrementation is done  and then initialized.

ex:
   int a=10;
   b=++a;
   a=11  b=11

Here first the value of a is incremented  and then initialized to b.

what is the ouput?

int a=6;
sop(a++);//
sop(a);//

case 5:
  difference between b++ and b=b+1;

ex1:
byte b=10;
b++;
Sop(b);//11


byte b=10;
b=b+1;
Sop(b);//ce
  

explanation
-----------
In java when ever we perform any operation all the operands in the expression(logic) must be of same type,otherwise compiler will perform upcasting(small datatype to big datatype) for required operands.In this process a method is called to apply possible promotions i,e 

max(int,typeofvar1,typeofvar2);

ex:
byte b=10;
b=b+1;

b is of type byte

1 is of type int(default int type)

max(int,byte,int)-->int


Here this method returns int,so compiler here promotes byte to int

int+int-->becomes int-->

final result is returned in int,but the operand at left side is byte so both are not compatible,we get compilation error.


Possible conversions in java
----------------------------
byte+byte-->int[max(int,byte,byte)]
byte+short-->int
short+short-->int
byte+char-->int
short+int-->int
int+int-->int
int+long-->long
int+float-->float
int+double-->double
float+long-->float
float+double-->double
long+double-->double

Ternary operators
-----------------
Operators applied on 3 operands is known as ternary operators.

Used to validate a condition.

syntax
------
expression1?expression2:expression3;


if expression1 is true then the statement after question mark(?) is executed otherwise the statement after colon(:) is executed.


ex:
   int a=50,b=20,c;
   c=a>b?a:b;
   System.out.println(c);//50


Bitwise operators
-----------------
Bitwise operators are used perform operation on bits.


1)Bitwise and-->&
2)Bitwise or-->|
3)Bitwise xor-->^
4)Bitwise right shift-->>
5)Bitwise unsigned right shift-->>>
6)Bitwise left shift--><<
7)Bitwise compliment-->~

Type conversion/type casting
----------------------------
The process of converting one datatype to another datatype is is known as type conversion.

There are 2 types of conversions

i)Implicit conversion.
ii)explicit conversion.

Implicit conversion
-------------------
Converting one datatype to another datatype automatically by a compiler is known as Implicit conversion.

ex:
class Test{
  public static void main(String args[])
  {
      byte b=10;
      int a=b;//line1
      System.out.println(a);
   }
}

output:10

exp
---
In the above code at line1 compiler promotes byte to int automatically and initializes the variable a.


Implicit conversion is also called as widening or upcasting.


Explicit conversion
-------------------
Converting one datatype to another datatype programatically is known as explicit conversion.

syntax
------
datatype var1=(type)var2;


ex:
class Test{
  public static void main(String args[])
  {
      int s=10;
      byte a=(byte)s;//line1
      System.out.println(a);
   }
}

Exp:
---
In the above program at  line1 we are explicitly promoting int to byte by using casting.

Explicit conversion is also called as narrowing or downcasting.

Control statements
------------------
Alter the flow of executon of a program.

we have the follwoing control statements 

i)decision making statement.
ii)loop control statement.
iii)case control statement.

i)decision making statement.
----------------------------
It checks whether a given a condition is true or false.

we have 2 types
if
if-else

if
--
An if statement checks whether a condition is true/false,of condition is true then if block gets executed otherwise execution of if block is skipped.

syntax
------
if(condition)
{
  //statements
}

Types of if
-----------
There are 3 types of if statement
i)simple if
ii)multiple if
iii)nested if

simple if
---------
declaring only one if statement in a program is known as simple if.


Multiple if
-----------
declaring more than one if statement in a program is known as multiple if statement.

syntax
------
if(condition1)
{
  //statements
}
if(condition2)
{
  //statements
}




concatenation operator(+)
-------------------------
In between 2 numeric operands always an arithmetic(+) is called while performing addition.

ex:
int a=10,b=5;
a+b

string+anything=string
anything+string=string
string+string=string

if we apply (+) operator between a string operand and any other operand always a concatenation(+) is called which simply combines operands.

ex:
  int a=10,b=5;
  String s="satya";
 
  a+b+s-->15satya
  s+a+b-->satya105
  a+b+s+a+b-->15satya105.

if-else
-------
It is used to check a condition.


if condition is true,if block is executed.

otherwise,else block is executed.

syntax
------
if(condition)
{
  //statements
}
else
{
  //statements
}


Multiple if-else
----------------
Declaring id-else more than once is known as multiple if-else


syntax
------
if(condition1)
{
  //statements
}
else
{
  //statements
}
if(condition2)
{
  //statements
}
else
{
  //statements
}
.
.
.

else-if ladder
--------------
It is used to check condition.
syntax
------
if(condition1)
{
  //statements
}
else if(condition2)
{
  //statements
}
else if(condition2)
{
  //statements
}
..
..
..
else
{

}

Here if condition1 is true then that if block is executed otherwise condition2 is executed otherwise condition3 is executed and so on.

If all the conditions are false then else block is executed.

greatest of 3 numbers
grades of a student

s1 s2 s3

avg>=75-->distinction

avg>=60 && avg<75-->First class

avg>=50 && avg<60-->second class

avg>=40 && avg<50-->Third class

otherwise 

fail


Nested if
----------
An if within another if is known as nested if.

syntax
------
if(condition1){

if(condition2){

if(condition3){
   //statements
}
}
}

class Test
{
  public static void main(String args[])
  {
      int a=400,b=3000,c=4200; 
      if(a>b)
      {
        if(a>c){
          System.out.println(" a is big "+a);
        }
      }
      else if(b>c)
      {
          System.out.println(" b is big "+b);
        
      }
      else{
         System.out.println(" c is big "+c);
      }
   }
}

Loop control statements
-----------------------
Loops perform a repititive task.

we have the follwing loops 

i)while
ii)do-while
iii)for
iv)foreach


Any loop requires
-----------------
Initialization
condition
inc/dec

Initialization
--------------
It specifies where loop should begin.

ex:
int i=1;

condition
---------
It specifies how many times a loop should iterate.

ex:
   i<=10

inc/dec
-------
increments or decrements a loop

i++;/i--;

while
-----
It performs a repititive task.

syntax
------
while(condition)
{
  //statements
  inc/dec;
}

Program to print numbers from 1 to 10
------------------------------------- 
class Loop{
  public static void main(String args[])
  {
    int i=1;
    while(i<=10)
    {
      System.out.println(i);
      i++;
     }
  }
}
Program to print numbers from 10 to 1
------------------------------------- 
class Loop{
  public static void main(String args[])
  {
    int i=10;
    while(i>=1)
    {
      System.out.println(i);
      i--;
     }
  }
}



   


Program to print even numbers
-----------------------------
//10 to 1
class Loop{
  public static void main(String args[])
  {
    int i=2;
    while(i%2==0&&i<=100)
    {
      System.out.println(i);
      i=i+2;
     }
  }
}

sum of 10 natural numbers
-------------------------
class Test{
  public static void main(String args[])
  {
     int i=1,sum=0;
     while(i<=10)
     {
       sum=sum+i;
       i++;
     } 
     System.out.println(sum);
  }
} 

Print even numbers from 1 to 100
--------------------------------
class Test{
  public static void main(String args[])
  {
     int i=1,sum=0;
     while(i<=10)
     {
       if(i%2==0){
            sum=sum+i;
       }
       i++;
     } 
     System.out.println(sum);
  }
} 

Print factors of a number
-------------------------
6

1  6%1==0
2  6%2==0
3  6%3==0
4  6%4==0
5  6%5==0
6  6%6==0


class Test{
  public static void main(String args[])
  {
     int i=1,n=8;
     while(i<=n)
     {
       if(n%i==0){
         System.out.println(i);
       }
       i++;
     } 
  }
} 


sum of factors
--------------
class Test{
  public static void main(String args[])
  {
     int i=1,n=8,sum=0;
     while(i<=n)
     {
       if(n%i==0){
           sum=sum+i; 
       }
       i++;
     }
    System.out.println(sum);
       
  }
} 



perfect number
-------------
sum of the factors if a given number excluding itself  must be equivalent to the given  number.


6 ->1
    2
    3 
    6

Prime or composite
------------------
class Test
{
   public static void main(String args[])
   {
      int i=1,n=2,count=0;
      while(i<=n)
      {
        if(n%i==0)
        {
          count++;
        }
        i++;
       }
       if(count==2)
       {
         System.out.println("prime");
       }
       else  
       {
         System.out.println("composite");
       }
      
    }
}



do-while
--------
It performs a repititive task until condition is false.

syntax
------
do
{
  //statements
}
while(condition);

In do-while body is executed for one time even if condition is false.

class Test
{
  public static void main(String args[])
  {
    int i=10;

    do{
      System.out.println(i);
      i--;
    }while(i>=1);
  }
}


for loop
--------
repeatitive statamet

syntax
------
for(initialization;condition;inc/dec)
{
  //statements
}

class Test
{
  public static void main(String args[])
  {
    int i;
    for(i=1;i<=100;i++)
    {
      if(i%2==0)
      System.out.println(i);
    }
}
}

switch
------
It is a case control statement.

switch is collection of cases.

syntax
------
switch(expression)
{
  case value1:statements;
              break;
  case value2:statements;
              break;
  case value3:statements;
              break;
  ...
  ...
  default:statements;
         
}  

In a switch case the value of expression is matched with the value of a case,whichever case is matching the value of expression that case gets executed.

break causes to stop the execution of switch

if none of the cases are matched then default statement gets executed.


Note:
 switch doesn't accept decimal and long values


oop[object oriented programming]
--------------------------------
An  oop consists of the following features

object
class
abstraction
encapsulation
inheritance
polymorphism
message passing
dynamic binding

object
------
It is a real world entity 

ex:
 Car,Bike,Pen etc

An object is instance of a class i'e it allocates memory for a class.

class
-----
It is blueprint of an object.
describes obout object
Collection of variables and methods.

abstraction
-----------
The process of providing essential information hiding background details is known as abstraction.


encapsulation
-------------
grouping of variables and methods into a single unit is known
as encapsulation.

inheritance
-----------
The process of deriving properties from a super to a sub class is known as inheritance.

A
|
B

polymorphism
------------
Ploy --many
morphism--forms

Representing same method in many forms(avtar) is known as polymorphism.

Message passing
---------------
Two objects communicating with each other using methods is known as message passing.


dyamic binding
--------------
Binding a method call with a method at runtime is known as dynamic binding.

classes and objects
-------------------
object
------
An object is a real world entity like Car,Bus,Bike
It is an instance of a class i,e it allocates memory for a class.

An object has

i)properties 
ii)actions


properties are used to identify object.
actions are behaviours

ex:

Car
Properties -->name
           -->color
           -->price
           -->cno

actions-->move()
       -->acceleration()
       -->speed()

Properties are represented using variables.

Actions are represented using methods.


syntax
------
ClassName referenceName=new ClassName();


class
-----
A class is blue print of an object

A class describes about properties and actions of an object.

A class is collection of variables and methods.

A class is declared by using a keyword "class".

syntax
------
accessmodifier class ClassName
{
  variables;
  methods;
}

ex:
Car-->name---String
   -->color--String
   -->price--double
   -->cno  --int


steps for working with classes and objects
------------------------------------------
step1:
 declare a class

 syntax
 ------
 accessmodifier class ClassName
 {
   //variables
   //methods
 }

 ex:
 class Car
 {
  
 } 

step2
----
create an object for a class.

syntax
------
ClassName referenceName=new ClassName();

ex:
Car c=new Car();

Step3
-----
Accessing members of a class.

syntax
------
referenceName.memberName

How to access variable
----------------------
referenceName.varname

ex:
c.name

How to access a method
----------------------
referenceName.methodname();

ex:
c.input();


Program
-------
class Book
{
  String name="harrypotter";
  String author="jkrowling";
  double price=1000.00;
}
class BookTest
{
  public static void main(String args[])
  {
     Book b=new Book();
     System.out.println(b.name);
     System.out.println(b.author);
     System.out.println(b.price);
  }
} 

In the above we are declaring 2 classes

i)Book
ii)BookTest


Book is used describes about book properties 

BookTest is a test class where we include main method to it
and test Book i,e creating objects and accessing members of a class.

main() is the starting point of execution to jvm.


methods
-------
A method is a subprogrm which performs a specific task.

we can divide a large program into small parts using methods,it is also called as modularization.

Methods provides code reusability.

Methods makes debugging easy.

Methods optimize code(reduces length of a code)

Methods provides readability.

Types
-----
There are 2 types of methods

i)default method
ii)Parameterized method

default method
--------------
A method without parameters is known as default  method

syntax
------
accessmodifier  returntype methodname()
{
  //statements
}

ex:
public void sum()
{
//
}

How to call a default method
----------------------------
syntax
------
referenceName.methodname();

ex:
s.sum();


class Triangle
{
 public void area()
 {
    double b=10.0,h=5.0,a;
    a=0.5*b*h;
    System.out.println(a);
  }
   
}
class TriTest
{
    public static void main(String args[])
    {
       Triangle t=new Triangle();
       t.area();
    }
} 


Parameterized method
--------------------
A method with parameters is known as parameterized method.


syntax
------
accessmodifier returntype methodname(datatype var1,datatype var2,.....)
{
//
}

ex:
public void sum(int x,int y)
{
//statements
}
Parameterized methods are used to perform parameter passing.

Parameter passing
-----------------
Passing values from one method to another method is known as parameter passing.

How to call a parameterized method
----------------------------------
syntax
------
referencename.methodname(value1,value2,....);

or

referencename.methodname(var1,var2,....);

ex:
s.sum(10,20);

or 

int a=10,b=20;
s.sum(a,b);



ex:
class Addition
{
   public void sum(int x,int y)//called method
   {                           //formal/dummy parameters
     int c=x+y;
     System.out.println(c);
   }
}
class AddTest
{
  public static void main(String args[])
  {
    Addition a=new Addition();

    int a=10,b=20;
    a.sum(a,b);//line1
               //method calling
               //actual parameters
   }
}

In the above program we are declaring a sum method with 2 parameters of int types.

The parameters declared with a method is called formal/dummy parameters.

The statement declared at line1 is called calling method/method calling.

The parameters passed to method calling is known as actual arguments.

whenever a method is called,the values of actual arguments are copied to formal arguments according to the order variables i.e first parameter from calling method is copied first argument of called method(the method itself).similarly second parameter to the second argument and so on.

The variables declared in a method are called local variables.

ex:
class Circle
{
   public void area(double r)
   {
     double pi=3.14,a;
     a=pi*r*r;
     System.out.println(a);
    }
}
class CirTest
{
   public static void main(String args[])
   {
      Circle c=new Circle();
      double x=10.0;
      c.area(x);
    }
}


Armstrong
---------
class ArmStrong
{
    public void logic(int n)
    {
       int temp=n,r,sum=0;
       while(n>0)
       {
           r=n%10;
           sum=sum+r*r*r;
           n=n/10;
        }
        if(sum==temp)
        {
          System.out.println("Arm");
        }
        else{
          System.out.println("Not An Arm");
        }
     }
}
class ArmTest
{
   public static void main(String args[])
   {
       ArmStrong s=new ArmStrong();
       s.logic(153);
   }
}



return type
-----------
It specifies the type of value a method is returning.

datatype before methodname is a returntype.

How to return value
-------------------
we can return a value from a method using the keyword

"return"

syntax
------
return value;

or

return variablename;


Note:
we can save a java program with any name and compile the program with that name we had saved, but while executing a program  we must run the program with the class that is having main method declared inside it.

ex:
class Book
{
   String name="twostates";
   String author="chetan";
   double price=150.00;
  
   
   //display  method
   public void display()
   {
       System.out.println(name);
       System.out.println(author);
       System.out.println(price);
      
   }
 
}
class BookTest
{
   public static void main(String args[])
   {
       Book b=new Book();
       b.display();
   }
}

         
save as 
 
Book.java

comiple
javac Book.java

run
---
java BookTest


Execution process of a java program
-----------------------------------
Execution of a java program always starts from main() method,it is starting point of execution to jvm.


main method must be declared as 

public static void main(String args[]).

Program
------
class Sum
{
  //instance variables
  int a;
  int b;
  int c;

  public void init(int x,int y)
  {
    a=x;
    b=y;
  }
  public void add(){
   c=a+b;
  }
  public void show()
  {
    System.out.println("The sum is "+c);
  }
  public static void main(String args[])
  {
    Sum s=new Sum();//line1
    s.init(1,2);//line2
    s.add();//line3
    s.show();//line4
  }
}



In the above code when line1 is excuted an object is created for Sum class in a memory area called heap.

An object declaration consists of 2 parts

Sum s      =     new Sum();
---------        ----------
reference        Object  part
part

An object part consists 

i)new operator
ii)constructor calling(Sum())

A new operator allocates memory for an object and invokes a constructor.

Construtor calling makes a call to a constructor of a class.

Whenever an object is created every object is provided with a unique address.

The address of object is initialized to a variable called as reference variable.


Methods are executed from a memory area called as stack as 
shown in diagram.

An object consists of instance variables of a class

what is instance variable?
variable declared inside a class and outside a method and non static is known as instance variable.


what is local variable?
variable declared inside a method is known as local variable.

creating multiple objects for a class.
-------------------------------------
We can create many objects for a class.

Program to create multiple objects for a car using parameter passing
-------


class Car
{

   String name;
   String color;
   double price;
   int cno;
  public  void input(String n,String c,double p,int no)
  {
    name=n;
    color=c;
    price=p;
    cno=no;
  }
   
  //display  method
   public void display()
   {
       System.out.println(name);
       System.out.println(color);
       System.out.println(price);
       System.out.println(cno);
    
      
   }
 
}
class CarTest
{
   public static void main(String args[])
   {
       Car car1=new Car();
       Car car2=new Car();
       Car car3=new Car();

       car1.input("audi","red",60000.00,7777);
       car2.input("bmw","pink",70000.00,6666);
       car3.input("lamborghini","yellow",80000.00,5555);

       car1.display();
       car2.display();
       car3.display();
   }
}
In the above program we are creating 3 objects for Car class,
here 3 copies of objects are created in heap.

Every object will have its own copy of instance variables as shown in diagram.

For each method declaration one copy of method is created and this method is shared by all the objects of class as shown in diagram.

Bitwise operators
-----------------
Operation on bits

i)bitwsie and--&
ii)bitwsie or--|
iii)bitwise xor--^
iv)bitwise right shift-->>
v)bitwsie unsigned right shift-->>>
vi)bitwise left shift--<<
vii)bitwise compliement--~


a   b   a&b  a|b  a^b
0   0    0     0    0
0   1    0     1    1
1   0    0     1    1
1   1    1     1    0

Default values
--------------
The values which are automatically initialized for instance variables and static variables of class by jvm is known as default values.

if user  is not providing values for both instance and static variables then such variables are initialized with default 
values.

Program
-------
class Default
{
   char ch;
   byte b;
   short s;
   int i;
   long l;
   float f;
   double d;
   boolean bl;
   String str;
   public void show()
   {
     System.out.println(ch);
     System.out.println(b);
     System.out.println(s);
     System.out.println(i);
     System.out.println(l);
     System.out.println(f);
     System.out.println(d);
     System.out.println(bl);
     System.out.println(str);

   }

  public static void main(String args[])
  {
      Default d=new Default();
      d.show();
  }
}


Default values
--------------
char --space
integer-0
decimal-0.0
boolean-false
reference type-null



static(modifier)
---------------
A modifier changes the behaviour of a member like variable/method/class/interface/enum when declared with one.


A static keyword declared with 

variables.
methods.   
inner classes.
blocks.


static variable
---------------
  A variable declared using a keyword static is known as static variable.

  static variables are automatically initialized with default values.

  A static variable is a variable for which only one copy of memory is created and it is shared by all the objects of a class.

 static variable is also called as shared variable.

syntax
------
accessmodifier static datatype varname=value;

ex:
   public static double pi=3.14;



Note
----
when should we use instance variables and static varibles?

If the value changes from one object to another object then such of values must be declared using insatnce variables.

For example 

    name of student changes from one student to another student,so it is good to delcare name as instance

If a value is common for the entire class and for all objects then such type of values are declared using statuc variable.

ex:
   pi=3.14

Generally we define constants as static in java.

static variables also acts as a kind of global variables.

For example 

   The name of college is same for all the students such type of variables must be declared as a static.


Quick questions
---------------

what is a static variable?
where should we declare static?
How many copies of memory is allocated?
static variables is also called as ---------variables.

static keyword is a --------.

static keyword is declared with -----,-----,-----,-----.

if the value of variable changes from one variable to another then declared that variable as -----

if the value is commom ,then declare as-------variable

what is an instance variable?
what is an instance method?
how many declaration scopes are there in java?
------- variable holds address of object.
variables declared in a method are called -----.
A construtor is --------method.
write four characteristics of constructor in two or 3 words.

Program
-------
class CountTest
{
   int count;
   public void incr()
   {
      count++; 
      System.out.println(count);
   }
   public static void main(String args[])
   {
      CountTest t1=new CountTest();
      CountTest t2=new CountTest();
      CountTest t3=new CountTest();

      t1.incr();
      t2.incr();
      t3.incr();
   }
}
output
------
1
1
1

Analysis
--------   
In the above code we are declaring an instance variable count.

we are calling incr() method on objects t1,t2,t3,as we know every object has a seperate copy of instance variable, we get the output as

1( t1.incr())
1(t2.incr())
1(t3.incr())
 
as shown in the diagram.



In the above program declare  variable "count" as a static variable

static int count;

then the output of the program is

1(t1.incr())

2(t2.incr())

3(t3.incr())

As shown in diagram static variable is a common variable shared by all the objects,so calling incr() on any object updates variable count.

Program
-------
class CountTest
{
   static int count;
   public void incr()
   {
      count++; 
      System.out.println(count);
   }
   public static void main(String args[])
   {
      CountTest t1=new CountTest();
      CountTest t2=new CountTest();
      CountTest t3=new CountTest();

      t1.incr();//1
      t2.incr();//2
      t3.incr();//3
   }
}

//11,11,11
//11,12,13
//10,10,10
//none


Note:
static variable save memory but declare it whenever it is necessary.


static method
-------------
A method declared using the keyword static is known as static method.

syntax
------
static accessmodifier returntype methodname()
{
//statements
}

A static method allows to access only static members(variables,methods) directly.

static members(variables,methods) are not part of object but they are part of class.

we can call static members directly using classname without creating object.

How to call static member
------------------------

static variable
---------------
syntax
------
  ClassName.varname


static method
-------------
   ClassName.methodname();



Program
-------
class Test
{
   static int a=10;
   
   static public void incr()
   {
      a++;   
      System.out.println(a);
   }
   public static void main(String args[])
   {
      Test.incr();
      System.out.println(Test.a);
   }
}

*we can access non-static members(instance variables,methods) from a static method/block by creating Object of a class.

ex:
class Test
{
   int a=10;
   
   static public void incr()
   {
      Test t=new Test();
      t.a++;   
      System.out.println(t.a);
   }
   public static void main(String args[])
   {
      Test.incr();
   }
}
 
In the above code  variable "a" is an instance variable,we are accessing that variable from static method incr() by creating object for the Test class as shown in the above code.

what instance  method?
Any non static method inside a class is known as instance method.

Instance varibles and instance methods are part of object,we can access them only by creating object,using either object or object reference

class Test
{
   int a;
   void show()
   {
     System.out.println("helo");
   }
   public static void main(String args[])
   {
       Test t=new Test();
       t.show();

       new Test().show();


   } 
}

Memory is allocated for instance variable,methods,blocks only when an object is created.


On the other hand static members are not part of object they are part of class so they are said to be in class scope,so we are able to call static members using classname.

Memory is allocated for static members as soon as .class file is loaded into memory.

we can exchange modifiers of a class or a method or a variable/enum/interface.

ex:
    public static void m1()
    {

    }

    static public void m1()
    {

    }

what is a static keyword?
what is static variable?
How many copies of memory is allocated?
static variable is also called as-----or-------.
what is a static method?
static allows to access ------ directly.
we can non static members in a static method by using ----of a clsss.
static members are part of ------.
static members are also called as-----.
instance members are part of-----.
Memory is allocated of instance members only by creating----
Memory is allocated of static members at time of ---- loading.
---- is called as instance method.
static memebers are directly accessed using ------.

Instance members must be accessed using -----or------.
Non static block inside ----and outside ---- is known as 
instance block.
instance block is called ----------- whenever which is created.
instance block is used to ---------


instance and static block 
-------------------------
instace block
-------------
A block is group of statements enclosed in between opening and closing braces.

syntax
------
     {
      //statements
     }

An instance block is a block declared in a class without any name.

An instance block is automatically called whenever an object is created.

An  instnace block is used initialize instance varibles of a class.

syntax
------
class ClassName
{

   .....;
   {
     //statements
   }
   ...;
}
Program
-------
class Test
{
   int a;
   
   { 
     a=20;
     System.out.println(a);
   }
    
   public void init()
   {
      a=40;
      System.out.println(a);
    } 
    public static void main(String args[])
    {

       Test t=new Test();
       t.init();

   } 

}

output
------
20
40

Here first instance  block is called. 

second init() is called after creating object.


static block
------------
A block declared using keyword static is known as static block.


syntax
------
    static
    {
     //statements
    }

      
static block is auotmatically executed whenever a .class is loaded into memory from a hard disk.

static block is used to initialize static variables at time of class loading.

static block is also used to perform pre-initialization i,e
intializing static variables or creating objects at the time of loading class itself is known as pre initialization.


example:
-------
class Test
{
   //instance block
   {
      System.out.println("hi");  
   }
   //static block 
   static 
   {
      System.out.println("hello");  
   }
   //main 
   public static void main(String args[])
   {
      System.out.println("gm");  
      Test t=new Test();
      System.out.println("ga");  
    
   } 
}

Analysis of program execution
-----------------------------
1--static block is executed
2--prints hello
3--main is executed
4--prints gm
5--Object is created 
6--instance block is called
7--prints hi
8--prints ga

output
------
hello
gm
hi
ga


what is the output?
class Test
{
   int a;
    
   static
   {
      Test t=new Test();
      t.a=10;
      System.out.println("hello"+t.a);  
   } 
   {
      System.out.println("hi");  
   } 
   public static void main(String args[])
   {
      System.out.println("gm");  
      Test t=new Test();
      System.out.println("ga");  
    
   } 
}

Ananlysis of execution flow
---------------------------
1--static block is called
2--Test object in static block is created
3--instance blocl is called--->hi 
4--instance variable is initialized-->hello10
5--main method is called
6--"gm" is printed
7--Test object in main is created
8--instance block is called->hi is printed
9--"ga" is printed


output
------
hi
hello10
gm
hi
ga

what is the output of the following code?
class Test
{
   int a;
    
   {
      Test t=new Test();
      System.out.println("hi");  
   } 
   public static void main(String args[])
   {
      System.out.println("gm");  
      Test t=new Test();
      System.out.println("ga");  
    
   } 
}

output
------
gm,hi,ga
cE
RE[StatkOverFlowError]
gm,hi,ga,hi
None 


what is a static block?
static block initializes -------variables
static block is excuted as soon as-----loaded into memory.
static block is used to peform---------.
-----block is always executed first in java.

constructors
------------
A constructor is a special method which is having same name as
classname.

A constructor doesn't have  return type.

A constructor is used to initialize instance variables of a class.

A constructor is automatically called whenever an object is created.


Types of constructors
---------------------
i)Default.
ii)Parameterized.


default
-------
A constructor without parameters is known as default constructor.

syntax
------

   class ClassName
   {
      //statements
      acessmodifier ClassName()
      {
        //initialization code
      }
      //statements
   }

ex:
    public Car()
    {
      //statements
    }


Program
-------
Car -->name.
    -->color.
    -->price.
    -->cno.

Parameterized constructor
-------------------------
A constructor with parameters is known as parameterized constructor.


syntax
------
class ClassName
{
    //statements
    accessmodifier ClassName(datatype var1,datatype var2,...)
    {


    }
    //statements
}

Program
-------
class Car
{
   String name;
   String color;
   double price;
   int cno;
   //constructor
   public Car(String n,String c,double p,int no)
   { 
      name=n;
      color=c;
      price=p;
      cno=no;
       
   }
    public void show()
    {
       System.out.println(name);
       System.out.println(color);
       System.out.println(price);
       System.out.println(cno);
    }
   public static void main(String args[])
   {   
      Car c1=new Car("bmw","white",100000.00,7777);
      Car c2=new Car("audi","white",100000.00,7777);


      c1.show();
      c2.show();
       

   }
}
  


An object declaration  consists of 2 parts

i)refernce part
ii)Object part

 
ex:
 Car c     = new Car("bmw","white",100000.00,777);
 reference    object part
 part

An object consists of 2 parts 

i)new operator
ii)Constructor calling

new operator allocates memory for object.

constructor calling is implicit part of object.

If we have multiple constructors in a class,we should creat a seperate object to invoke(call) each constructor of a class.

Program
-------
class Car
{
   String name;
   String color;
   double price;
   int cno;
   //default 
   public Car()
   {
      name="lambo";
      color="white";
      price=20000.00;
      cno=5555;
    
   }   
   //Parameterized constructor
   public Car(String n,String c,double p,int no)
   { 
      name=n;
      color=c;
      price=p;
      cno=no;
       
   }
    public void show()
    {
       System.out.println(name);
       System.out.println(color);
       System.out.println(price);
       System.out.println(cno);
    }
   public static void main(String args[])
   {   
      Car c1=new Car();//line1
      Car c2=new Car("bmw","white",100000.00,7777);//line2
      c1.show();
      c2.show();
             

   }
}

line1--is invoking default constructor.
line2--is invoking parameterized constructor.

Declaring multiple constructors is known as constructor overloading.
Constructor overloading gives an opportunity for the developer to choose different ways of creating object,based on requirement developer can choose the required constructor while instantiating a class.
[will discuss more about overloading in polymorphism]


If developer is not including any constructor in a  class then the compiler will automatically include a default constructor to a class which is also called system default constructor,that is why we don't get any compilation error while making a call to default constructor even though we don't declare any constructor in a class.

Program
-------
class Car
{
   String name;
   String color;
   double price;
   int cno;
   
   public void show()
   {
     System.out.println(name);
     System.out.println(color);
     System.out.println(price);
     System.out.println(cno);
   }
   public static void main(String args[])
   {   
      Car c1=new Car();
      c1.show();
     
   }
}
 
Analysis
--------
In the above code we didn't  declare any constructor in Car class but we are making a call to default construtor,here compiler will automatically add one default constructor to a class.

A system default  constructor will initialize instance variables to default values if developer is not initializing instance variables.

Program
-------
class Test{

   {
     System.out.println("hello");
   }
   static 
   {
     System.out.println("hi");
   }
   public Test()
   {
     System.out.println("hiiiiiii");
   }
   public static void main(String args[])
   {
      System.out.println("GM");
      Test t=new Test();
      System.out.println("GN");

    }
}

output
------
hi
GM
hello
hiiiiii
GN

Note
----
Redeclaration of anything is not possible in java within same scope except for instance and static blocks.


what is the output of the following code?

class Test{

   {
     System.out.println("hello");//5
   }
   static //1
   {
     System.out.println("hi");
   }

   public Test(int x,int y)//7
   {
     System.out.println("hiiiiiii");
   }
  
  
   public static void main(String args[])//3
   {
      Test t=new Test(10,20);//4
   
    }
    static //2
    {
     System.out.println("Prabhas");
    }
    {//6
     System.out.println("Pawan");
    }

}
output
------
hi 
prabhascon
hello
pawan
hiiiiii
 

A  constructor has same name as -------
constructor doesn't have ------
constructor iniatizes -------
constructor is automatically called when-------
default constructor doesn't have-----
Parameterized constructor doesn't have-----
Advanatge of construtor?
instance block or constructor ----is called first.


access modifier
---------------
.An access modifier specifies accessibility of members of a program i,e

class.
variable.
method.
constructor.
interface.
enum.
inner class.

we have 4 accessmodifiers

public. 
private.
default.
protected.


public 
------
public is a keyword declared with

variables
methods
constructors
classes
interfaces
enum
inner class


A public member can accessed anywhere throughout the project.[It has maximum access]


syntax
------
accessmodifier datatype varname;

ex:
 public int a;


Method
------
accessmodifier returntype methodname()
{

}
ex:
public void show()
{
}

class
-----
accessmodifier class ClassName
{
}
ex:
public class A
{
}

etc


private
-------
private can be declared with

variables
methods
inner classes.

A private member can be accessed within a class itself,it is not accessible outside a class.

private is most restricted accessmodifier.

ex:
class A
{
  private int a=10;

  ....;
  ....;
} 


default
-------
if we don't declare any accessmodifier in a program then the access of members of a program are said to be in default access.


ex:
class A
{
  int a=10;

  ....;
  ....;
} 

Here class A, variable a are in default access.

The default access of a class in java is "default".


Any member of a program can in default accees i,e

variable
method
class
interface
enum
innerc class



A default member can be accessed anywhere in the same package but it is not allowed to access in other packages.

The scope of default members is a package itself.


protected
---------
protected keyword can be declared 

variables.
methods.
inner classes.

A protected member can be accessed anywhere in the  same package and by subclasses of other package.

Arrange the following acccessmodifiers according access from highest to least

public>protected>default>private
public>default>protected>private
private>deafult>protected>public
protected>default>private>public



Note
----
we cannot declare access modifiers with local variables.

inheritance
-----------
Deriving properties of a super class to a sub class is known as inheritance.

It avoids repitition of code.

save memory.

Maintainence of project becomes easy.

code readability.

code resuability.

we can have proper code modularization with inheritance.

ex:
         Flower
         name
         color
         price
|          |         | 
Rose     Jasmine   Lotus.

All the common properties of sub classes are declared in a class called as super class.

A super class is top class level class.

A sub class is a bottom level class.

we can extend(inherit) one class from the other using "extends" keyword.

A private member of a super is not inherited to a sub class.

Types of inheritance
--------------------
we have 5 types of inheritance

i)single inheritance
ii)Multi level inheritance
iii)heirarchical inheritance
iv)Multiple inheritance
v)Hybrid inheritance

single inheritance
------------------
 A
 
 ^
 |
 
 B            

Deriving one subclass from one super class is known as single inheritance.

Multi level inheritance
-----------------------
A

 
^
|

B

^
|

C
.
.
.
.

Deriving a sub class from a super class and in turn deriving another sub class from the derived class and so on is known as multi level inheritance.

Program
-------
class A
{
 int a;
 int b;
  
 public void init()
 {
   a=10;
   b=20;
 }  
 public void display()
 {
    System.out.println(a);
    System.out.println(b);
  }
}
class  B extends A
{
    int c;
    public void sum()
    {
       c=a+b;
       System.out.println(c);
    }
}
class  C extends B
{
    int d;
    public void mul()
    {
       d=a*b*c;
       System.out.println(d);
    }
    public static void main(String args[])
    {
        C c=new C();
        c.init();
        c.display();
        c.sum();
        c.mul();
        
    }
    
}

    
In a multi level inheritance, a sub class can access the properties of all its super classes.

Whenever we create an object for a sub class,a sub class object internally consists of a super class object as shown below.



Heirachical inheritance
-----------------------
Deriving 2 or more subclasses from a super class is known as heirarchical inheritance.

     A
^    ^  ^
|    |  |
B    c  D

Program
-------
class A
{
 int a;
 int b;
  
 public void init()
 {
   a=10;
   b=20;
 }  
 public void display()
 {
    System.out.println(a);
    System.out.println(b);
  }
}
class  B extends A
{
    int c;
    public void sum()
    {
       c=a+b;
       System.out.println(c);
    }
}
class  C extends A
{
    int d;
    public void mul()
    {
       d=a*b;
       System.out.println(d);
    }
    public static void main(String args[])
    {
        B b=new B();
        b.init();
        b.sum();

        C c=new C();
        c.init();
        c.mul();


        
    }
    
}

In heirarchical inheritance we inherit properties from a super class to sub class,but its not possible to inherit properties from subclass to subclass.

Multiple inheritance
--------------------
Deriving a sub class from 2 or more super classes is known as multiple inheritance.

In the above code 




Hybrid 
------
Combining any 2 inheritances is known as hybrid inheritance.



single inheritance
------------------

syntax
------
      accessmodifier class SuperClassName
      {
        //statements
      }
accessmodifier class SubClassName extends                                              SuperClassName
      {
        //statements
      }

Program
-------
class A
{
    int a;
    int b;
    public void input()
    {
      a=10;
      b=20;
    }
    public void display()
    {
      System.out.println(a);
      System.out.println(b);
    }
}
class B extends A
{
int c;
public void sum()
{
   c=a+b;
   System.out.println(c);
}
public static void main(String args[])
{
   B b=new B();
   b.input();
   b.display();
   b.sum();
  
}

}

In the above we are deriving one sub class(B) from one super class(A).

In inheritance it is recommended to create object for a sub class because a sub class can access properties of both sub class as well as super class.


In heritance we can inherit properties of super class to sub class but reverse is not possible i,e we cannot inherit properties of sub class to super class.


Internal representation of objects
----------------------------------
Whenever we create an object for a sub class,a sub class object internally consists of a  super class object as shown in diagram.

How many objects are created?

public static void main(String args[])
{
   A a=new A();
   B b=new B();
  
}

i)1
ii)2
iii)3
iv)No objects are created


Note:
if we declare a static block both in a super and sub class,they are executed from super class to sub class as soon as a .class file is loaded.


In java for each class one .class file is created,
if we have 10 classes then 10 .class files are created.

   No of classes=No of .class file

In a java file we can declare only one public class,if we declare more than one public class we get CE.
example
-------
what is the output of the following code?

public class A
{
}
public class B
{
}

i)compiles but not execute
ii)complies and execute
iii)CE
iv)RE

Analysis
--------
We must declare only one public class in a file.


If we declare a class as public in a file then we must save that file using classname that is declared as public.

example
-------
public class A
{
}
class B
{
}

save as
A.java

Multi level inheritance
-----------------------

syntax
------
accessmodifier class SuperClassName
{

}
accessmodifier class SubClassName1 extends SuperClassName
{

}
accessmodifier class SubClassName2 extends SubClassName1
{

}
.
.
.
.


Deriving super class to sub class is called-------

--- types of inheritances.

----inheritance is not supported in java.

It is recommended to create object for------.

A sub class objects internally consists ------.

-----no .class files are create in a program.

we can declare only one --------class in a file.

If we declare a class as public then we should save that program with-------.

In inheritance , we can derive properties from super to subclass and viceversa
true
false.

main method
-----------
public static void main(String args[])

public--A public method can be accessed by any         program.

static--A static method is a methid which can be         accessed using ClassName without creating         object.

void--doesn't return any value.

main--Execution of a java program begins from main       method,infact it inidcates starting point of       execution to jvm.

String args[]--command line arguments,used to accept                values from command prompt.

Note:
    We can compile a java program without main but we cannot execute a java program without main.

 
Upto 1.6 version  it is possible to partially execute a java program using static blocks but from 1.7 version onwards we must declared main method to execute a java program.

We can declare multiple main methods in a java program but not in the same class, but in different classes.

Program
-------
class X
{
    public static void main(String args[])
    {
      System.out.println("X");
    }

}
class Y extends X
{
    public static void main(String args[])
    {
      System.out.println("Y");
    }

}
class Test extends Y
{
    public static void main(String args[])
    {
      System.out.println("Test");
    }

}

save as XYZ.java


we can save a java program with any name,if we dont have any public class in a file.

While executing we should run the program by using a class that is having main method inside it.
 

How to compile
--------------
javac XYZ.java


How to execute
--------------
java X
X
or
java Y
Y
or
java Test
Test

In a program we can declare atmost one public class,if we declare more than one class as public it leads to compilation error.

ex:
public  class A
{

}c 
class B
{

}

If we declare a class a public in a file then we must save our file with the name class that is declared as public

ex:
public class A
{

}

save as
A.java.

Every class in java is inherited from a super class called as Object class either directly or indirectly.

Object class is available in the package java.lang.*;

example
-------
Object
 ^
 |
 A
 |
 B
 |
 C
 .
 .
 .

abstract
--------
An abstract keyword is declared with 

i)methods.
ii)classes.

abstract method
---------------
A method declared using the keyword abstract is known as abstract method.

An abstract method doesn't have any body.

we should terminate an abstract method using semicolon;

syntax
------
       abstract accessmodifier returntype methodname();

abstract classs
---------------
   A class declared using the keyword abstract is known as abstract class.

we should an abstract method in an abstract class,we can't declare an abstract method in a concrete class.

we can declare an abstract as well as concerete methods in an abstract class.

It is not compulsory to declare an abstract method in an abstract class.

we cannot create object for abstract class.

syntax
------
 accessmodifier abstract class ClassName
 {
   //
 }

  ex:
  abstract class A
  {
     public abstract void m1();
     public abstract void m2();

     public abstract void m3()
     {

     }
  }


abstract methods are used as a method contract in a project.

An abstract is used if we want partial implementation of a class.

we implement abstract methods of  an abstract in a subclass.

If a subclass extends abstract class then the subclass must implement all the abstract methods of abstract class.

Program 
-------
abstract class A
{
    abstract public void m2();
    abstract public void m3();
    
    public void m1()
    {
      System.out.println("m1");
    }
   
 

    }
  class B extends A{

     public void m2()
     {
      System.out.println("m2");
     }
      
      public void m3()
      {
        System.out.println("m3");
      }
      public static void main(String args[])
      {
        B b=new B();
        b.m1();
        b.m2();
        b.m3();
      }
  }

If a subclass extends abstract class then the subclass must implement all the abstract methods of abstract class otherwise the subclass also must be declared as abstract because the abstract method of a super class is inherited as abstract method only,but we know a concrete class doesn't allow abstract methods so we should mark the subclass as abstract.

Program
-------
abstract class A
{
   public abstract void m1();
   public abstract void m2();
   public abstract void m3();
   public void m4()
   {
     System.out.println("m4");
   }
}
abstract class B extends A
{

   public void m1()
   {
     System.out.println("m1");
   }
   public void m2()
   {
     System.out.println("m2");
   }
   
 
}
class C extends B
{
public void m3()
{
  System.out.println("m3");
}
public static void main(String args[])
   {
      C c=new C();
      c.m1();
      c.m2();
      c.m3();
      c.m4();
    
   }
}
   
In the above program we are declaring 4 methods m1,m2,m3,m4 in class A

m1,m2,m3-->abstract
m4-->concrete method

2--we are extending A to B
3--implementing methods of A in B,but we are not overriding all the abstract methods in subclass.
4--Marked subclass B as abstract,we if don't implement all the abstract methods in a subclass we should declare subclass also as abstract
5--Extending B -->C
6--Implementing m3() 
7--Testing Program  using main() in C class.
8--Here C is a concrete subclass so we create an object for C class and invoke properties of C,as well as  its abstract super classes A,B.

Concrete method
---------------
A method with body is known as concrete method.

ex:
 void m1()
 {
 }

Concrete class
--------------
A class which consists of only  concrete methods is known as concrete class.


ex:
 class A
 {
 void m2()
 {
 }
 void m3()
 {
 }
 void m1()
 {
 }
}  
 

abstract keyword is declared with ----and -----.
A concrete class allows abstract methods
true
false
An abstract class consists of both ---and ---methods.
we can create object for abstract class
Abtract methods of super class are implemented in a -------.
we should override --------methods of abstract super class in a subclass otherwise the subclass also must be declared as--------.
we should use abstract class if we want -------implementation.
An abstract method is a method---------body.

Polymorphism
------------
Poly means many 
morphism--forms

Representing same method in many forms is known as polymorphism.

There are 2 types of polymorphsim
i)compile time.
ii)run time. 

Compiletime polymorphism
------------------------
If method binding happens at the time of compiling a program itself,it is known as compiletime polymorphism.

what is method binding
----------------------
The process of matching a method call to its appropriate method is known as method binding

void m1()//1
{

}
void m1(int x,int y)//2
{
}
void m1(int x,int y,int z)//3
{
}


m1(10,20,30)//1
m1(10,20)//2
m1()//3
m1(10,20,30,40)//4

Here the following mapping gives order of matching betwteen method and method call.

1-3
2-2
3-1.

we implement compiletime polymorphism by using method overloading.

compiletime ploymorphism occurs based on reference.

Method overloading
------------------
The process defining same method with different parameters is known as method overloading.


Rules for overloading methods
-----------------------------
i)The name of the method must  be same
ii)The parameters should be different i,e the datatype of parameters must change or no of parameters must change.


Program
-------
class Greatest
{
   public void max(int x,int y)
   {
     if(x>y)
     {
       System.out.println(x +" is greater");
     }
     else{
       System.out.println(y +" is greater");
     }
   }
  public void max(double x,double y)
   {
     if(x>y)
     {
       System.out.println(x +" is greater");
     }
     else{
       System.out.println(y +" is greater");
     }
   }
   public static void main(String args[])
   {
        Greatest t=new Greatest();
        t.max(10,20);
        t.max(10.5,20.5);

       
   }
}

The purpose of overloading is, to the same method we can pass different parameters which reduces introducing number of new method definitions in an API[Application programming interface].

While calling a method,compiler will try find exact match of method,if the match is not found compiler try to promote parameters to the next level,still if the match  is not found,we get compilation error.

ex:
   public void max(int x,int y)
   {
    //statements
   }

   byte a=10,b=20;
   t.max(a,b);

In the above code we are calling max method by passing byte values but we dont have a max method declared with byte parameters so the compiler will promote byte parameters to int parameters.


we can pass different parameters like byte,short,int,.. to a method with double parameters,we know all the primitives are promted to double(except boolean).But here the problem is ,it requires datatype promotion which reduces performance of application.


ex:
  public void max(double x,double y)
   {
   }


  //case1
  byte a=10,b=20;
  t.max(a,b);

  //case2
  short a=10,b=20;
  t.max(a,b);

  //case3
  int a=10,b=20;
  t.max(a,b);

  ..
  ..
   
In the above code we are passing byte,short,int,.. parameters to max method,here all parameters are promoted to double type but this conversion is going to cost,it reduces performance so finally it is recommended to declare a method with exact match.

while calling a method a compiler considers the following characteristics.

i)Name of the method.
ii)No of parameters.
iii)Type of parameters.


Metod overloadin is declaring------ methid in -----forms.

While overloading parameters of method must------.

what is puprose of overloading?

while binding a method compiler consider the following parameters?

CP accurs based on ------.


----doesn't participate in overloading.


Runtime polymorphism
--------------------
If method binding happens at the time of executing a program is called as runtime ploymorphism.

we implement runtime polymorphism using method overriding.

Runtime polymorphism occurs based on object.

Method overriding
-----------------
The process of declaring methods of super class in sub class with same signature(method definition) but with different implementation is known as method overriding.

ex:
class A
{
  void marriage()
  {
    System.out.println("subba lakshmi");
  }
}
class B extends A
{
  void marriage()
  {
    System.out.println("Lekya");
  }
}


rules of overriding
-------------------
i)while overriding the signature of a method must be same in both super class and sub class.

signature means(returntype+methodname+parameters).

we may have a change in return types while overriding a method,such change in return type is called as covariant return type.

ex:
   class A
   {
      public Object m1()
      {
         return 10;
      }
   } 

   class B extends A
   {
      public String m1()
      {
         return "10.5";
      }
   } 

In the above code the return type in the super class method m1()  is object,the return of subclass method m1() which is overridden is String,here string is a subclass of Object because we known every class in java is inherited from a super class called object.

This change in return types from parent class to that of child class where the return type of parent class method is a superclass(Object) whereas the return of the subclass method is a child(String) of the returntype of superclass method,is known as co variant return types.


void m1()
{
}
int m1()
{
}

accessmodfiers in overriding
----------------------------
While overriding,the  method in the super class is known as overridden method.

The method in the subclass is called overriding method.

ex:
class A
{
  void m1()//overridden
  {
  }
}
class B extends A
{
  void m1()//overriding
  {
  }
}

*while overriding a method,we should keep the accessmodifier of overriding method same as overridden method otherwise, if possible we can increase the accessmodfier of overriding method, but we cannot decrease the accesslevel of overriding method.

ex:
what is the output?
class A
{
  void m1()//overridden
  {
  }
}
class B extends A
{
  void m1()//oveirriding
  {
  }
}


i)compiles 
ii)CE
iii)None

what is the output?
class A
{
  void m1()//overridden
  {
  }
}
class B extends A
{
  public void m1()//oveirriding
  {
  }
}
i)compiles 
ii)CE
iii)None

Here we had increased the accesslevel of the overriding method to public from default which is the accesslevel of overridden method.

what is the output?
class A
{
  public void m1()//overridden
  {
  }
}
class B extends A
{
  void m1()//oveirriding
  {
  }
}
i)compiles 
ii)CE
iii)None

Here we are trying to decrease the accesslevel of overriding method compared to that of overridden method.we get compilation error saying

m1() in B cannot override m1() in A.
attempting to assign weaker access privileges.


overriding private methods
--------------------------
we cannot override private methods because private methods are not visible to sub classes.

ex:
class A
{
  private void m1()
  {
    System.out.println("A");
  }
}
class B extends A
{
  void m1()
  {
    System.out.println("B");
  }
  
}
Here the method in the sub class is a sub class specific method but not overriding method because overriding is not applicable for private methods.

overriding variables
--------------------
overrding is not applicable for variables.


ex:
class A
{
  int a=10;
}
class B extends A
{
  int a=20;
}

Here we are not overriding variables.


runtime polymorphism[dynamic method dispatch]
---------------------------------------------
In java a super class reference can refer to a subclass object but reverse is not possible i,e a sub class reference cannot refer to a super class object.

ex:
class A
{
   void m1()
  {
    System.out.println("A");
  }
  
}
class B extends A
{
 
  void m1()
  {
    System.out.println("B");
  }
  public static void main(String args[])
  {
     A a=new A();
     B b=new B();
     a.m1();//
     b.m1();//
     
     A a2=new B();
     a2.m1();//
    

  }
  
}

dynamic method dispatch
-----------------------
The process of binding a method call to a method at runtime by jvm is known as dynamic binding or dynamic method dispatch. 

In the above example we are initializing a sub class object to a super class reference,here compiler cannot decide which method to bind(call) whether a method from sub class or super class so here jvm will take care of method resolution based on object.This approach is called as dynamic method dispatch.

overriding static methods
-------------------------
we cannot override static methods,if we override static methods it is called as method hiding i,e the method of sub class will hide the method of super class.

Program
-------
class A
{
  static void m1()//overridden
  {
    System.out.println("A");
  }
}
class B extends A
{
   static void m1()//overriding
  {
    System.out.println("B");
  }
  public static void main(String args[])
  {
     A a=new A();
     B b=new B();
     a.m1();//A
     b.m1();//B

     A a2=new B();
     a2.m1();//1
  }
}


output
------
A
B
A

In the above code we are overriding static method m1(),here it is not overriding but method hiding.Here method binding happens based on reference.when we call  m1() at line1 the method from super class A is called but not from subclass,here method binding occured based on reference.

comiple time polymorphism is also called as static polymorphism.

Runtime polymorpshism is also called as dynamic polymorphism.


declaring abstract and static with a method is illegal,leads to compilation error.

which of the following declarations are valid?

i)abstract void m1();
ii)public abstract void m1();
iii)public static abstract void m1();
iv)static abstract void m1();
v)abstract public void m1();
vi)abstract public static void m1();
vii)public static void m1();


comments in java
----------------
Java supports 3 types of comments

i)c comment
/* 
comments
*/

ii)cpp comment

//single line comments

iii)java doc
/**
comments
*/

comments increases readability.

dynamic initialization in java
------------------------------
we use a class Scanner available in java.util.* to initialize values dynamically from keyboard.

Method summary
--------------
byte--nextByte()
short-nextShort()
int --nextInt()
long--nextLong()
float-nextFloat()
double-nextDouble()
boolean-nextBoolean()
String-next()
      -nextLine()

ex:
Scanner s=new Scanner(System.in);
int a=s.nextInt();

Architecture of jvm
-------------------
ClassLoaderSubSystem
--------------------
A ClassLoaderSubSystem will load .class file from hard disk to ram.

A jvm consists the following run time memory areas 

i)MethodArea.
ii)Heap.
iii)Stack.
iv)Counter.
v)NativeMethodStack.

MethodArea
----------
It consists of class code including static variables,static methods.

Memory for static variables is allocated in MethodArea.

heap
----
heap is memory area where objects are placed.

Instance variable exists inside object.

stack
-----
stack is a memory area where methods are executed.

Local variables come to life in stack and die in stack.

Memory for local variables is allocated at the time of executing method in stack,local variables are deleted from stack at the time of method unloading once the exection of method is completed.

counter
-------
A counter consists of address of next instruction to be executed by jvm.

NativeMethodStack
-----------------
Native methods are executed from a memory area called NativeMethodStack.

Native method
-------------
Methods other than java like c,cpp,python etc.


----is the memory where class code is placed.

----is the memory where objects are placed.

----is the memory where methods are executed.

----consists of next instruction to be fetched.

----is the memory where native methods are executed.

Arrays
------
Array is a collection of similar type of values.

In one variable we can store many values using arrays.

static collection(fixed in size).

Arrays stores both primitives and objects.

Arrays are type safe.

Arrays are good at performance.


Types of arrays
---------------
one dimensional
Multi dimensional


one dimensional
---------------
Array with one subscript or one index is known as one dimensional array.

syntax
------
datatype varname[]=new datatype[size];

we can also declare array as below

datatype []varname=new datatype[size];
datatype[] varname=new datatype[size];

ex:
int a[]=new int[5];

Internal representation of arrays
---------------------------------
If the above statement is executed memory for array is allocated with 5 locations,the index of array always start with zero(0) and ends with size-1(4).

--
  |a[0]
--
  |a[1]
--
..


Programs
--------
import java.util.*;
class Test
{
  public static void main(String args[])
  {
     int a[]=new int[5],sum=0;
     int b[]=new int[5];
     Scanner s=new Scanner(System.in);
     System.out.println("Enter values into array");
     for(int i=0;i<5;i++)
     {
        a[i]=s.nextInt();
 
     }
     for(int i=0;i<5;i++)
     {
       b[i]=a[i];
 
     }
     for(int i=0;i<5;i++)
     {
        System.out.println(b[i]);
     }
   }
}

Initializing Array using Array Initializer
------------------------------------------
Array initializer is used to initialize  group of values with in parenthesis.
syntax
------
datatype varname[]={value1,value2,....};

Program
-------
import java.util.*;
class Test
{
  public static void main(String args[])
  {
      int a[]={1,2,3,4,5,6,7};
      for(int i=0;i<7;i++)
      {
         System.out.println(a[i]);
      }
    
   }
}

length variable
---------------
A length returns length of an array.

syntax
------
arrayvar.varname

ex:


Note:we cannot initialize size at the left the side of assigment operator in arrays;


which of the following array declarations are valid?
int a[]=new int[5];v
int a[]=new int[];iv
int a[5]=new int[5];iv
int a[5]=new int[];iv
int []a=new int[5];v
int[] a=new int[5];v

import java.util.*;
class Test
{
  public static void main(String args[])
  {
      int a[]={4,2,3,4,5,6,4};
      int count=0;

      System.out.println("Enter key"); 
      int key=new Scanner(System.in).nextInt();


      for(int i=0;i<a.length;i++)
      {
         if(a[i]==key)
         {
           count++;
         }
       }
       if(count>0)
       System.out.println("element "+key+" is found "+count+" times ");
       else
       System.out.println("element not found");
 }
}



2D Array
--------
Array with 2 subscripts is known as 2D Array.

2D Array is used to represent data in the form of rows and cols.

syntax
------
datatype varname[][]=new datatype[size1][size2];

size1-->rows
size2-->cols


ex:
int a[][]=new int[2][2];

internal representation
-----------------------



Program
-------
a.length.

3D Array
--------
Array with 3 subscript or index is known as 3D Array.

collection of 2d arrays.

syntax
------
datatype varname[][][]=new datatype[size1][size2][size3];

ex:
int a[][][]=new int[2][2][2];

size1-->no of 2d arrays
size2-->no of rows
size3-->no of cols

int a[]=new int[5];

If we try to insert/print values in an array we should not exceed the size of array,it leads to ArrayIndexOutOfBoundsException if we exceed the size.

Also we should not use negative index while working with arrays.

If we don't initialize an array it is automatically initialized with default values.

ex:
Program
-------
class Test
{
   public static void main(String args[])
   {
        int a[]=new int[5];

        for(int i=0;i<5;i++)
        {
           System.out.println(a[i]);
        }
   }
}
output
------
0
0
0
0
0

Arrays are obejects in java.we know that we create objects using new operator.
Arrays static collection i,e they are fixed in size


this
super
this()
super()



this
----
this is keyword used to refer to current class instance varaibles and methods.

this cannot used in static context.


syntax
------
How to access variable
----------------------
this.varname

ex:
this.name

How to access methods
---------------------
this.methodname();

ex:
this.show();


super keyword
-------------
A super keyword is used to refer to instance variables and instance methods of super class from a sub class.

super cannot be used in static context.


How to access variable
----------------------
super.varname

ex:
super.a

How access methods
------------------
super.methodname();

ex:super.display();





Program to demonstrate super keyword
------------------------------------
class A
{
int a=10;
public void display()
{
System.out.println(a);
}
}
class B extends A
{
int a=20;
public void display()
{
  System.out.println(a);
  System.out.println(super.a);
  super.display();
   
}
public static void main(String args[])
{
   B b=new B();
   b.display();

}
}


Note:
It is recommended to use super keyword if both the super class memebers and sub class members are same.

 
what is the output of the follwoing program?
Program
-------
class A
{
 int a=10;
}
class B extends A
{
 int a=20;
}
class C extends B
{
 int a=30;
 public void show()
 {
   System.out.println(a);
   System.out.println(super.a);
   System.out.println(((A)this).a);//line1
 } 
 public static void main(String args[])
 {
    C c=new C();
    c.show();
 }
}
output
------
30
20
10


In the above code we are trying acces the instance variable of "A" class from "C" class,super keyword is applicable upto one level of inheritance.so to invoke the variable from A class to C class we had done casting as shown at line1.


this()
------
It is used to invoke one constructor from another constructor of same class.

Chaining of constructor within the same class is possible using this().


this() is of 2 types
default-->this();
parameterized-->this(value1,value2,...);
                   or
                this(var1,var2,...);


this() must be the first statement in a constructor.

//case1:Chaining parameterized from default
class Test
{
   Test()
   {
     System.out.println("1");
   }
   Test(int x,int y)
   {
     this();     
     System.out.println("2");
   }
}
class ThisTest
{
  public static void main(String args[])
  {
     Test t1=new Test(10,20);
   
  }
}

//case2:Chaining  parameterized from another //constructor
class Test
{
   Test()
   {
     this(30,40);
     System.out.println("1");
   }
   Test(int x,int y)
   {
          
     System.out.println("2");
   }
}
class ThisTest
{
  public static void main(String args[])
  {
     Test t1=new Test();
   
  }
}


what is the output of the following code?
class A
{
   A()
   {
      this(10);
      this(10,20);//line1
   }
   A(int x)
   {
    
   }
   A(int x,int y)
   {
   }
   public static void main(String args[])
   {

   }
}
//i)compiles
//ii)executes
//iii)cE[tick]
//iv)RE

In the above code this() method is declared as a second statement @line1.As per rule this() must be first statement in a constructor.


class A
{
   A()
   {
      this();
      System.out.println("A"); 
   }
   public static void main(String args[])
   {
       A a=new A();
       
   }
}
options
-------
i)CE
ii)RE
iii)Exceutes sucessfully and prints A
iv)None of the above.

Ans:
CE 

Analysis
--------
The above program leads to CE saying "recursive constructor invocation" because we are calling same constructor repeatitively by declaring default this() inside default constrcutor.



Construtor calling in inheritance
---------------------------------
In java contructor is not inherited from super class to subclass because a construtor purpose is to initialize instance variables of a class in whihc it is declared.

In java,A sub class contructor will automatically make a call to its super class constructor but this is applicable only to default constructors.


While calling a super class construtor from a sub class constructor we use super() method.

super()
-------
A super() is used to make to call the constructor of a super class from a sub class constructor.

A super() must declared as a first statement in a sub class constructor.

A super() is of 2 types
default--->super()
       --->It is used to make a call to default constructor of a super class from a sub class constructor.

parameterized--->super(value1,value2,...);
                  or
             --->super(var1,var2,...);
--->It is used to make a call to parameterized constructor of a super class from a sub class constructor.

--->we can pass parameters from a sub class constructor to a super class constructor by using parameterized super() method.

Program to  demonstrate default super()
---------------------------------------
class A
{
   A()
   {
     
     System.out.println("A");
   }
  
}

class B extends A
{
   B()
   {
     super();
     System.out.println("B");
   }
}
class C extends B
{
   C()
   {
    super();
    System.out.println("C");
   }
   public static void main(String args[])
   {
       C c=new C();

   }

}
 
output
------
A
B
C
Important points
----------------
In the above code we are making a call to super class constructor B() from C() by using super(),similary from B() to A().


In case of default constuctors,if we don't declare a super() in a sub class constructor then the compiler will implicitly(automatically) add one super() in a sub class constructor.

program to demonstrate Parameterized super()
--------------------------------------------
class A
{
  A(int x,int y)
  {
    System.out.println("A "+x+y);
  }
}
class B extends A
{
  B(int x,int y,int z)
  {
    super(x,y);
    System.out.println("B "+x+y+z);
  }
}
class C extends B
{
  C(int x)
  {
    super(x,10,20);
    System.out.println("C "+x);
  }
  public static void main(String args[])
  {
    C c=new C(10);
    
  } 
}



if we declare a constructor of a super class as private then it is not possible to inherit that super class.

Program
-------
class A
{
  
   private A()
   {
   }
 
}

class B extends A
{
   B()
   {
   }

}

The above code leads to CE saying  A() has private access.



final variable
--------------
A variable whose value cannot be altered/changed is known as final variable.

A variable declared using keyword final is known as final variable

syntax
------
final datatype varname=value;

ex: 
final double pi=3.14;

if we want to define constants in a program then we must declare a variable as final.

The only modifier allowed with local variables is final.

we should initliaze a final variable at the time of declaring itself.

final method
------------
A method declared using a keyword final is known as final method

we cannot ovverride final methods in a subclass.


syntax
------
accessmodifier final returntype methodname()
{
//statements
}

ex:
public final void m1()
{

}

Program
--------
class A
{
  public final void m1()
  {
    System.out.println("A");
  }
}
class B extends A
{
  public void m1()
  {
    System.out.println("B");
  }

}

Above code leads to CE because we are overriding final method.

which of the following method definitions are valid?
public final void m1()
public final  abstract void m1()
public final static abstract void m1()
public abstract void m1()
void m1()
public static final void m1()

we cannot declare abstract and final together bcoz it is iilegal combination.abstract method must be overridden whereas final method shoud not be overridden.


final class
-----------
A class declared using keyword final is known final class.

A final class cannot be inherited.

syntax
------
accessmodifier final class ClassName
{
//
}

ex:
final class A
{
  public  void m1()
  {
    System.out.println("A");
  }
}

which of the following declarations are valid?
public final class A{}c
public abstract class A{}c
public final abstract class A{}
public static final class A{}
final class A{}c
abstract class A{}c
public abstract static final class A{}


Reason:A final class cannot be subclassed whereas an abstract class needs subclassing.

interface
---------
interface is similar to a class which consists

final fields
abstract methods
default methods
static methods

we declare interface using keyword "interface"

syntax
------
accessmodifier interface interfacename
{
  //final fields
  //abstract methods
  //default methods
  //static methods
}

ex:
 public interface Shape
 {
    public static final double pi=3.14;
    abstract public double area();
 }

By default variables of interface are public static and final.

By default methods of interfaces are public and abstract.

we implement an interface in a class.

we use the keyword "implements" to implemet interface in a class.

syntax
------
interface InterfaceName
{

}
class SubClass implements InterfaceName
{

}

A -----variable cannot be modified.
final variables  are used to declare-----
-------is the only modifier declared with local variables.
------method cannot be overridden.
------and ----- combination is illegal.
------class cannot be inherited.
we can restrict inheritance in ---ways and they are -------and -------.
interface consists of---,---,---,---.
------keyword is used to declare interface.
variables of interface are by default---,---,---.
abstract methods of interface are by default ---and ---.
we  -------interface in a------using------keyword.


we override abstract methods of interface in a sub class.

if we implement interface in a class we should override all the abstract methods of interface in a subclass otherwise the subclass also must be declared as abstract.

we cannot instantiate interfaces.

Program
-------
package com.manohar.java;
interface  I1{
	void m1();
	void m2();
	void m3();
}
public class I1Impl implements  I1 {

	@Override
	public void m1() {
	  System.out.println("m1");	
	}

	@Override
	public void m2() {
		  System.out.println("m2");	
				
	}

	@Override
	public void m3() {
		  System.out.println("m3");	
				
	}
	public static void main(String[] args) {
	   I1Impl  i1=new I1Impl();
	   i1.m1();
	   i1.m2();
	   i1.m3();
	   
	}

}

Multiple inheritance using interfaces
-------------------------------------
Deriving a subclass from 2 or more super classes is known as multiple inheritance.

we can implement any number of interfaces in a subclass depends on requirement.

syntax to implement multiple interfaces in a subclass
--------
interface interface1
{

}
interface interface2
{

}
.
.
.

class SubClassName implements interface1,interface2,...
{
//
}

In java we can extend only one class from another class whereas we can implement multiple interfaces in a subclass.

Program
-------
package com.manohar.java;
interface I1
{
	public abstract void m1();
	public abstract void m2();
}
interface I2{
	public abstract void n1();
	public abstract void n2();
}
public class I1Impl implements  I1,I2{

	@Override
	public void m1() {
	   System.out.println("m1");	
	}
	@Override
	public void m2() {
		   System.out.println("m2");	
		
	}
	@Override
	public void n1() {
		   System.out.println("n1");	
	}
	@Override
	public void n2() {
		   System.out.println("n2");	
	}
	
	public static void main(String[] args) {
		I1Impl  impl=new I1Impl();
		impl.m1();
		impl.m2();
		impl.n1();
		impl.n2();
		
		
		//
		I1 i1=new I1Impl();
		i1.m1();
		i1.m2();
		
		I2 i2=new I1Impl();
		i2.n1();
		i2.n2();
		
		
	}

}

interfaces supports loose coupling.

coupling
tight coupling
loose coupling(interfaces)

coupling
--------
The degree of dependency of one class on another is called as coupling.

Tight coupling
Loose coupling


Tight coupling
--------------
The degree of dependecy of one class on another is high such kind of coupling is called tight coupling.

ex:
class A
{
  B b=new B();


}
class B
{
   C c=new C();


}
class C
{

}

In the above code if A must exist before that B must exist,if B must exist before that C must exist.Here there is a  dependecy of one class on another such kind of dependency is called Coupling.

Loose coupling
--------------
if there is less dependency of one class on another we call this as loose coupling.

we can accomplish loose coupling by using pojo-poji model.


POJI--Plain old java  interface[simple java interface].
POJO--Plain old java Object[simple java class].


In a simple note implementing an interface in a class is known pojo-poji model which is  higly useful in frameworks.

Program
-------
interface Vehicle
{
   public abstract void move();
  
}
class Bus implements Vehicle
{
   public void move()
   {
     System.out.println("Hey iam on Bus");
   }
}
class Car implements Vehicle
{
   public void move()
   {
     System.out.println("Huuu iam on Car");
   }
}
class Journey{
  private Vehicle v;
  public Journey(Vehicle v)
  {
     this.v=v;
  }
  public void travel()
  {
    v.move();
  }
}
class Test
{
  public static void main(String args[])
  {
     Bus b=new Bus();
     Car c=new Car();

    Journey j1=new Journey(c);
    j1.travel();
  }
}


In the above code we are implementing Vehicle interface in Bus and Car classes.

This approach makes objects loosely coupled,as we know from dynamic method dispatch a super class refer to a sub class object,an interface reference also can refer to its implementation class objects.

May be we can't instantiate interfaces,abstract classes but still the reference of interface or abstract class can refer to a subclass to object.

This approch is very popular in jdbc,spring,hibernate etc.

In the above code we are declaring Journey class,it consists of Vehicle as instance variable.

we are initializing Vehicle through constructor as shown in the above code.

Declaring object of one class in another class is called as HAS-A relation also this called as composition.

In the code Vehicle is called as dependency in Journey class.

Journey is called dependent.

In tight coupling if we make any changes to a dependency automatically it will affect dependent i.e if we make changes to Bus or Car then Journey will get affected.see below code.

ex:
class Journey
{
  Bus b=new Bus();
  ..
  ..
}
Here in the above  code if we replace Bus with Car i,e if we change dependency then Journey get affected.

So whenever we make changes to dependency it is going to impact dependent to avoid this loose coupling is introduced.

we can achieve loose coupling with above approach declared in Journey class,here we are using inteface reference to refer to subclass objects using constructor injection.

Here to the constructor we may pass Car object or Bus object we dont need to make any changes to Journey,so it reduces dependency of objects in a class.

Constructor injection
---------------------
Passing primitives or objects to a constructor is called Constructor injection.


case1:
if 2 interfaces has same methods then it is sufficient to provide a common implementation for both for these interfaces in a subclass for one time.

Program
-------
interface I1
{
  public abstract void m1();
}
interface I2
{
  public abstract void m1();
}
class I1I2 implements I1,I2
{
   public void m1()
   {
     System.out.println("m1");
   }
   public static void main(String args[])
   {
     I1I2 i1=new I1I2();
     i1.m1();
   }
 
}
  

case2:if 2 interfaces has same variables then we should invoke them in a sub class using InterfaceName,as we know variables of interface are final static and public,so we can access a variable of inteface using InterfaceName,otherwise it leads to ambiguity error.


Program
-------
interface I1
{
   int a=10;
}
interface I2
{
  int a=20;
}
class I1I2 implements I1,I2
{
   public void m1()
   {
     System.out.println("a is "+I1.a);
     System.out.println("a is "+I2.a);

   }
   public static void main(String args[])
   {
     I1I2 i1=new I1I2();
     i1.m1();
   }
 
}
  

Extending interfaces
--------------------
It is possible to extend one interface  from another interface.

syntax
------
accessmodifier interface Interface1
{
//

}
accessmodifier interface Interface2 extends Interface1
{
//

}

Program to demonstrate extending one interface from another and implementing in a subclass.
--------------------------------------------------
interface I1
{
   public abstract void m1();
   public abstract void m2();

}
interface I2 extends I1
{
   public abstract void m3();
}
class I1I2 implements I2
{
   public void m1()
   {
     System.out.println("m1");
   
   }
   public void m2()
   {
     System.out.println("m2");
   
   }
   public void m3()
   {
     System.out.println("m3");
   
   }
   
   public static void main(String args[])
   {
     I1I2 i1=new I1I2();
     i1.m1();
     i1.m2();
     i1.m3();

   }
 
} 

In the above code we are extending I2 from I1 and implementing I2 in a subclass I1I2,here if we impement I2 in a subclass it is sufficient and we should override both the abstract of I1,I2. 

case1:
we can extend multiple interfaces to another interface i,e multiple inheritance is possible between interfaces.

Program
-------
interface I1
{
   public abstract void m1();
   public abstract void m2();

}
interface I2 
{
   public abstract void m3();
}
interface I3 extends I1,I2
{
   public abstract void m4();
}

class I1I2 implements I3
{
   public void m1()
   {
     System.out.println("m1");
   
   }
   public void m2()
   {
     System.out.println("m2");
   
   }
   public void m3()
   {
     System.out.println("m3");
   
   }
   
   public void m4()
   {
     System.out.println("m4");
   
   }
   
   public static void main(String args[])
   {
     I1I2 i1=new I1I2();
     i1.m1();
     i1.m2();
     i1.m3();
     i1.m4();

   }
 
}

Hybrid multiple inheritance
---------------------------
It is possible to extend a class and implement interfaces together in a subclass.

syntax
------
class Class1
{

}
interface I1
{

}
interface I2
{

}
..
class SubClass extends Class1 implements I1,I2,...
{

}

Program
-------
class Class1
{
   public void m1(){
     System.out.println("m1");
   }
 
}
interface I1 
{
   public abstract void m2();
}

class ABC extends Class1 implements I1
{
   public void m2()
   {
     System.out.println("m2");
   
   }
   public static void main(String args[])
   {
     I1I2 i1=new I1I2();
     i1.m1();
     i1.m2();
   
   }
 
}
  


default methods in interfaces
-----------------------------
A method with default implementation in an inteface is called as default method.

we should declare default method in interface using "default" keyword.

syntax
------
public default returntype methodname()
{

}
ex:
public default void m1()
{

}

default methods makes maintenance of projects easy and simple.

suppose over a period of time the number of abstarct methods we add to interfaces increases to a level where addition of new abstract methods to an interface becomes difficult because the number of implementation classes also grows parallely once we introduce a new abstract method all the implementation classes  should override these methods even if is necessary or not,to avoid this situation default methods are introduced so that we don't need to implement these methods in a subclass,the subclass which needs these methods will override them and the other classes may use default methods as it is.

Program
-------

interface I1 {
	void m1();

	void m2();

	default void m3() {
		System.out.println("m3");
	}
}

class A implements I1 {

	@Override
	public void m1() {
		System.out.println("m1");
	}

	@Override
	public void m2() {
		System.out.println("m2");
	}
}

public class DefaultDemo {
	public static void main(String[] args) {

		A a = new A();
		a.m1();
		a.m2();
	
		a.m3();

	}
}
static method
-------------
We can declare static methods in interfaces from 1.8 version onwards.

static methods are used to implement utility logic.

syntax
------
public  static returntype methodname()
{
//
}

Program
-------
interface I1 {
	public static int max(int x, int y) {
		if (x > y) {
			return x;
		} else {
			return y;
		}
	}

	public default void m3() {
		System.out.println("m3");
	}
}

class A implements I1 {
	public void m1() {
		System.out.println("m1");
	}

}

public class DefaultDemo {
	public static void main(String[] args) {

		A a = new A();
		a.m1();
		a.m3();
		System.out.println(I1.max(10, 20));

	}
}



packages
--------
A package is collection
classes
interfaces
enum

It is a reusable component
It provides code modularization
It avoids naming conflict.
It provides code optimization.
Maintenance of project is easy using packages.


Types of packages
-----------------
i)Predefined package.
ii)Userdefined package.


Built-in/existing packages are predefined.

java.lang.*;
It is a General purpose package which consists of classes and interfaces like
System
String
Runnable
etc

It is also called default package because 
it is automatically imported by a compiler if developer is not importing.

java.util.*;
It  consists of classes like
Stack,Queue,LinkedList etc.

java.io.*;
It is used to perform input/output operations(file operations)
FileInputStream.
FileOutputStream.

java.sql.*;
It is used to perform jdbc operations.
It consists of interfaces like
Connection
Statement
etc.

java.applet.*;
java.awt.*;
javax.swing.*;

The above packages are used to perform GUI programming.

Userdefined packages
--------------------
package defined or created by developer is known as userdefined package.


How to declare a package.
-------------------------
we declare a package by using a keyword "package".

syntax
------
package packagename;

ex:
package  pack1.*;

package declarartion must be the first statetment in a program.

packages must be declared in lowercase.


why packages
------------
Grouping related classes into  a single unit.

Reusability.

packages avoids naming conflict.

packages supports code modularization.

readability.


creating userdefined package;

syntax
------
package packagename;
accessmodifier class Class1
{
}
accessmodifier class Class2
{
}
.
.
accessmodifier interface Interface1
{
}
accessmodifier interface Interface2
{
}
.
.
accessmodifier enum EnumName1
{
}
.
.


Program to add a class to package
---------------------------------
package pack1;
public class A
{
  public void m1() 
  {
    System.out.println("m1");
  }  
}

How to save a package.

save as
ClassName.java
ex:
A.java

How to compile a package
------------------------
javac -d . Classname.java 

-d is a flag which creates a directory(folder) with the name of a package declared in a program.

.(dot) represents current directory.

similary Add 2 more classes to a package
package pack1;
public class B
{
  public void m1() 
  {
    System.out.println("m1");
  }  
}
save as B.java


package pack1;
public class C
{
  public void m1() 
  {
    System.out.println("m1");
  }  
}
save as C.java

importing packages
------------------
We import a package by using a new keyword "import".

Types of import
---------------
implicit.
explicit.

implicit import
---------------
All the members of a package are automatically available for  a program,such an import is called implicit import.


syntax
------
import packagename.*;

ex:
import java.lang.*;
import pack1.*;

Program to demonstrate implicit import
--------------------------------------
import pack1.*;
class Test
{
  public static void main(String args[])
  {
      A a=new A();
      a.m1();

      B b=new B();
      b.n1();
   
      C c=new C();
      c.n1();

  }
}

Explicit import
---------------
Import a specific class/interface/enum to  a program is known as explicit import.

syntax
------
import packagename.ClassName;
or
import packagename.InterfaceName;
or
import packagename.EnumName;

ex:
import java.lang.Math;
import pack1.A;

Program to demonstrate explicit import
--------------------------------------
import pack1.A;
import pack1.B;

class Test
{
  public static void main(String args[])
  {
      A a=new A();
      a.m1();

      B b=new B();
      b.n1();
   
    
  }
}

Here only A,B classes are imported to Test class.


static import
-------------
A static import is used to invoke static methods of a class without using classname.


syntax
------
import static packagename.ClassName.*;

ex:
import static packagename.Math.*;

Program
-------
import static java.lang.Math.*;
public class Test  {
	public static void main(String[] args) {

       System.out.println(sqrt(25.0));
       System.out.println(sqrt(45.0));
       System.out.println(sqrt(36.0));
       System.out.println(sqrt(64.0));
     }
}

In the above code we are calling sqrt() method of Math class without using classname,this is possible because we are using static import.

static import increases performance of an application but at the same time it is confusing to the developer.

Fully Qualified Name of a class
-------------------------------
we can directly use a class or member of a package in a program by using fully qualified name without importing a package.

syntax
------
packagename.membername

ex:
java.util.Scanner

Program
-------
public class Test  {
public static void main(String[] args) {
int a;
java.util.Scanner  scanner=new java.util.Scanner(System.in);
System.out.println("enter a");
a=scanner.nextInt();
System.out.println(a);
     
}
}

This is used for instant purpose.

creating packages in eclipse
----------------------------
open eclipse-->

file-->new--->java project-->

projectname--->packages

select-->use default jre.

goto package explorer-->Expand project-->src-->rightclick-->new-->package-->
                    name--->test

Adding a class to a package in eclipse
--------------------------------------
Goto Project-->packages-->src-->test-->right click on package-->new-->class-->
                   Name-->A-->ok

Program
-------
package test;

public class A {
	public void m1()
	{
		System.out.println("m1");
	}
}


Add 1 more classe to test package

package test;

public class B {
public void m1()
{
	System.out.println("B");
}
}

importing classes  of one package in another package in eclipse
-------------------------------------------
create another package pack1.

Add a class Demo.

package pack1;

import test.A;
import test.B;
public class Demo {
	public static void main(String[] args) {
		A a=new A();
		B b=new B();
		a.m1();
		b.m1();
		
	}

}

accessmodifiers in packages
---------------------------
public members are accessible through out project.

default members are accessible within a package.

private members are accessible within a class itself.

protected members are accessible anywhere in same package and by sub class of other package.

Program
-------
package test;
public class A {
protected void m1()
{
	System.out.println("A");
}
}


package pack1;
import test.A;
public class Demo extends  A{
	public static void main(String[] args) {
        Demo d=new Demo();
        d.m1();
}
}

In the above program we are invoking the protected method m1() from test package in pack1 by extending class A to Demo as shown in the above code.

Nested packages
---------------
A package within another package is known as nested package.

syntax
------
package package1.package2.package3...;

ex:
package pack1.pack2;

Nested packages provides better modularization of related classes,interfaces,enum.


Exception handling
------------------
Exception is a  runtime error which terminates a program abnormally.

Errors
------
It is a deviation in a program.

There are 3 types of errors

i)compiletime/syntax errors.
ii)Runtime errors.
iii)logical errors.

compile time errors
-------------------
Errors raised due to wrong syntax.

ex:
semicolon missing;
undefined symbol a
etc

Runtime error
------------- 
A runtime error causes a program to terminate abnormally at the time of executing a program.

ex:
ArrayIndexOutOfBoundsException.
ArithmeticException.

Runtime errors is also called as Exceptions.

logical errors
--------------
It causes to get wrong output.


Program
-------
class Test
{
   public static void main(String args[])
   {
     int a=10,b=0,c;
     c=a/b;//line1
     System.out.println(c);
     System.out.println("The end");

   }
}

The above program raises runtime error @line1, because we are trying to divide a number by zero 
saying

Exception in thread "main" java.lang.ArithmeticException: / by z
        at Test.main(Test.java:6).



An Exception is raised because of a risky statement in a program.

In the abovne code 
c=a/b; is a risky statement.

A risky statement may raise exception but we can't guarantee that exception is always raised because of risky statement it depends on input provided by user.

Exception Handling
------------------
It is a mechanism which avoids abnormal termination of a program.

we implement execption handling using the following keywords

i)try
ii)catch
iii)finally
iv)throws
v)throw

try
--- 
A try block consists of   risky statements.

Whenever an execption is raised in try block then it is thrown to catch block.

syntax
------
try
{
//risky statements
}

catch
-----
A catch block catches the exception thrown from try block.

A catch catches the exception thrown from try block and avoids abnormal termination of a program

Here catch is handling the exception so catch block is called as EXception handler.

syntax
------
catch(ExceptionType reference)
{
//statements
}

we can handle exception by using try/catch block.
syntax
------
try
{
//risky statements
}
catch(ExceptionType reference)
{

}

Program
-------
class Test
{
   public static void main(String args[])
   {
     int a=10,b=0,c;
     try
     {
       c=a/b;
       System.out.println(c);
     }
     catch(ArithmeticException e)
     {

     }
     System.out.println("The end");
  }
}
Execution flow of try/catch
---------------------------
A catch block is executed only if an execption is raised in a try block otherwise a catch block is never executed.

finally
-------
A finally block is used to perform cleanup operations.

A finally block can be declared after try block or catch block.

syntax
------
try
{
}
catch()
{
}
finally
{
}

or
try
{
}
finally
{

}

Cleanup operations means closing connections like 

closing file connections.
database connections.
network connections.

Program
-------
import java.util.Scanner;
import java.util.InputMismatchException;

class Test
{
  public static void main(String args[])
  {
    Scanner s=new Scanner(System.in);
    System.out.println("enter a");
    try
    {
      int a=s.nextInt();
      System.out.println(" a"+a);
 
    }
    catch(InputMismatchException e)
    {
         System.out.println(e);
 
    }
    finally
    {
        s.close();      
 
    }
    System.out.println("The end");
 
   
  }
}


Excecution flow try/catch/finally
---------------------------------
A try block is always executed.

A catch block is executed only when execption is raised in try block.

A finally block is always executed irrespective of exception. 

A try block must be declared with a catch block or finally block.


which of the following declarations are valid?

i)try
  {
  }
  catch()
  {
  }

ii)try
  {
  }
  catch()
  {
  }
  finally
  {
  }
iii)
  try
  {
  }
  finally
  {
  }  

iv)try
   {
   }
v)catch()
  {
  }


Exception Heirarchy  
-------------------
    Object
      ^
      |
    Throwable
 ^                                     ^        
 |                                     | 
Exception                              Error
|                                       |
IOException      RuntimeException      StackOverFlow
ServletException    |                  |Error
etc               ArithemeticException |Assertion
                  ArrayIndexOutOfBounds|Error
                  Exception
                  NullPointerException 
                  etc



Object is the super class of all classes in java.

Throwable is the super class of Exception and Error.

Exception is used to handle programmatic issues.

Error is used to handle system issues.


Types of exceptions
-------------------
Exceptions are of 2 types
i)checked 
ii)Unchecked

checked
-------
Exceptions which are checked by compiler are called checked exceptions.

Exception is always raised at runtime but compiler will raise an error if there any possibility of Exception at runtime such type of exceptions are checked exceptions.

Exceptions like IOException,ServletException etc are checked exceptions.

Unchecked
---------
Exceptions which are checked by jvm and not checked by compiler are called unchecked exceptions.

RuntimeException and its subclasses and Error and its subclasses are unchecked exceptions and remaining are checked exceptions

Exception and Throwable are partially checked exceptions because they has both checked and unchecked classes as subclasses.


Note:Majority of Exception classes are available in java.lang.* package.


throws
------
throws is used to throw or delegate an exeception from a method.

throws is used to throw only checked exceptions.

syntax
------
accessmodifier returntype methodname()  throws ExceptionType
{


}
Program to demonstrate handling checked exception IOException
-------------------------------------------------------------
Program
-------
import java.io.*;
class Test
{
  public static void main(String args[]) throws IOException
  {
     DataInputStream dis=new DataInputStream(System.in);
     String name=dis.readLine();
    System.out.println(name);
   
  }
}

DataInputStream is a class available in java.io.*;

readLine() is used to input value from keyboard.

readLine() method throws checked exeception,IOException.

we can handle a checked exeception in 2 ways 

i)Using try/catch
ii)using throws keyword.

In the above code we are hadling IOException using throws,here we are simply forwarding(delegating) exception to jvm but we are not handling exception,it is jvm which handles exeception here.


Note:if we want to handle exception explicitly in the code itself then we should use try/catch block.

try with mutiple catches
------------------------
we can declare a try block with mutiple catch clocks.

if we declare muiptle risky statements in try block,to handle this multiple exceptions thrown from try we can use multiple catch blocks.

syntax
-----
try
{
//risky statement1
//risky statement2
.
.

}
catch(ExceptionType1 reference)
{
} 
catch(ExceptionType2 reference)
{
} 
.
.
.



program to handle AE and AIOOBE using try with multiple catches
---------------------------------------------------------------
import java.io.*;
class Test
{
  public static void main(String args[])
  {
    int a=10,b=0,c;
    int x[]={1,2,3,4,5};

    try{
      c=a/b;//line1
      System.out.println(c);
      System.out.println(x[6]);//line2
    }
    catch(ArithmeticException e)
    {
      System.out.println(e);
   
    }
    catch(ArrayIndexOutOfBoundsException e)
    {
         System.out.println(e);
      
    }
 
    System.out.println("Byee");
   
  }
}


In the above code we are declaring 2 risky statements @line1,@line2


@line1 may raise ArithemeticException.

@line2 may raise ArrayIndexOutOfBoundsException


to  handle both the exceptions we are declaring  catch blocks,one with ArithemeticException and the other with ArrayIndexOutOfBoundsException.


If exception is raised @line1 then its corresponding catch block with ArithmeticException  is executed .

If exception is raised @line2 then its corresponding catch block with ArrayIndexOutOfBoundsException  is executed.


A catch block handling all the exceptions
-----------------------------------------
A cathc block can handle any exception thrown by try block if we declare the parameter of catch as super class i,e

if we declare "Throwable" class as a parameter it can handle any exception/error thrown from try block.

syntax
------
try
{

}
catch(Throwable e)
{
}


if we declare "Exception" as a parameter it can handle any exception thrown from try block but it cannot handle errors

syntax
------
try
{

}
catch(Exception e)
{
}

if we declare "Error" as a parameter it can handle any error thrown from try block but it cannot handle exceptions.

syntax
------
try
{

}
catch(Error e)
{
}

Program to handle mutiple exceptions using a catch block
--------------------------------------------------------

//what is the output of the following code?
class CatchTest
{
    public static void main(String args[])
    {
     
         int a=10,b=0,c;
         int x[]={1,2,3,4,5};
          
         try
         {
            c=a/b;
            System.out.println(c);
            System.out.println(x[4]);
         }
         catch(Exception e)
         {
              System.out.println(e);
         }
         catch(ArithmeticException e)
         {
              System.out.println(e);
         }
         catch(ArrayIndexOutOfBoundsException e)
         {
              System.out.println(e);
         }
         
    }
}
        
/*options
-------
i)CE
ii)RE
iii)compiles successfully
iv)compiles and executes*/


Reason
------
In the above code we get compilation error because the catch block with exception as parameter will handle all the excetions thrown from try block,and other catch blocks never get a chance for execution.

so we get a compilation error saying

"Exception ArithmeticException has already been  caught"

same for ArrayIndexOutOfBoundsException.


Note:
Whenever we are declaring mutiple catch blocks,always declare parameters to catch blocks from sub class to super calss i,e  declare a catch block with subclass as parameter first and then declare a catch block with its super class as as a parameter.


Rewriting above program to fix compilaion error
------------------------------------------------
class CatchTest
{
    public static void main(String args[])
    {
     
         int a=10,b=0,c;
         int x[]={1,2,3,4,5};
          
         try
         {
            c=a/b;
            System.out.println(c);
            System.out.println(x[4]);
         }
         catch(ArithmeticException e)
         {
              System.out.println(e);
         }
         catch(ArrayIndexOutOfBoundsException e)
         {
              System.out.println(e);

         }
         catch(Exception e)
         {
              System.out.println(e);
         }

   }
}



Here catch with subclasses as parameter is declared first and catch block with a superclass[Exception] is kept last in the heirarchy.


UserDefined exceptions
----------------------
Exceptions  are of 2 types 

i)Built-in exceptions
ii)Userdefined


Built-in are predefined or existing exceptions.

NullPointerException.
ArithmeticException.

etc

Exceptions developed by developer are called userdefined exceptions.


We can create our own exceptions by extending a class from built-in exception.

The nature of userdefined exception depends on the kind of super class it is extending.

steps for creating userdefined exceptions
-----------------------------------------
step1:extend a class from a built-in exception like Exception\Throwable\Error\RuntimeException etc depends on requirement.

accessmodifier class ClassName extends Exception
{


}
step2:declare a parameterized constructor with String as a parameter.
accessmodifier class ClassName extends Exception
{
  accessmodifier ClassName(String msg)
  {
   
  }


}
step3:Declare super() in the contructor and deligate the String parameter to super class constructor.
accessmodifier class ClassName extends Exception
{
  accessmodifier ClassName(String msg)
  {
       super(msg);
   
  }
}

throw
-----
A throw keyword is used to throw an exception from a try block to catch block programatically or explicitly.

we can throw both built-in and userdefined exceptions using throw keyword but it is recommended to use throw keyword to throw userdefined exceptions because predefined exceptions are automatically thrown from try block catch block by jvm.

syntax
------
throw new ExceptionType(args);

ex:
throw new ArithmeticException("Division by zero");
throw new InvalidSalaryException("Incorrect Amount");


Program to demonstrate userdefined exception
--------------------------------------------
//create a Exception InsufficientFundsException

package com.manohar.java.exceptions;
public class InsufficientFundsException extends  Exception{
   public InsufficientFundsException(String msg){
	   super(msg);
   }
}
//create a BalTest.java to test exception
---------------------------------------
package com.manohar.java.test;
import java.util.Scanner;
import com.manohar.java.exceptions.InsufficientFundsException;
public class BalTest {
public static void main(String[] args) {
// declaring variables
double bal = 10000.00;
double amount;

// creating scanner
Scanner s = new Scanner(System.in);
System.out.println("Enter amount");
amount = s.nextDouble();

if (amount > bal) {
try {
throw new InsufficientFundsException("Please enter proper amount");
}
catch (InsufficientFundsException e) {
System.out.println(e);
}
}
else{
System.out.println("Amount withdrwn "+amount);
System.out.println("Ramaining bal "+(bal-amount));
}
}
}

Displaying Exception Summary
----------------------------
Exception summary can be displayed 3 ways.
i)Printing reference of Exception.
ii)getMessage().
iii)printStackTrace().


i)Printing reference 
This approach displays both exception and message
System.out.println(e):

ii)getMessage()
This approach displays only message
System.out.println(e.getMessage());

iii)printStackTrace()
This method  display complete summary of exception
e.printStackTrace();


Program
-------
class Test
{
  public static void main(String args[])
  {
     int a=10,b=0,c;
     try
     {
       c=a/b;
       System.out.println(c);
     }
    catch(ArithmeticException e)
    {
      System.out.println(e.getMessage());
      System.out.println(e);
      e.printStackTrace();
    }
}
}

output
------
/ by zero//getMessgae()
java.lang.ArithmeticException: / by zero//printing reference
java.lang.ArithmeticException: / by zero//stack Trace
        at Test.main(Test.java:8)


catch with multiple parameters
------------------------------
We can declare multiple paramters with a catch block from 1.7 version onwards.

syntax
------
try
{
//statements
}
catch(ExceptionType1|ExceptionType2|...  reference)
{

}

Program
-------
class Test
{
  public static void main(String args[])
  {
     int a=10,b=10,c;
     int x[]={1,2,3,4,5};
     try
     {
       c=a/b;
       System.out.println(c);
       System.out.println(x[6]);
 
     }
    catch(ArithmeticException|ArrayIndexOutOfBoundsException e)
    { 
      e.printStackTrace();
    }
}
}

try with resources
------------------
Generally we use finally block to perform clean up operations but by using try with resources we dont need to use finally block because closing connections is automatically done by using try with resources.


syntax
------
try(rerefence type)
{
 
}
catch(ExceptionType e)
{
}

Program
-------
import java.util.*;
class Test
{
  public static void main(String args[])
  {
    try(Scanner s=new Scanner(System.in))
    {
       System.out.println("Enter a");
       int a=s.nextInt();
       System.out.println(a);
    }
    catch(InputMismatchException e)
    {
      e.printStackTrace();
    }
    System.out.println("The end");
}
}

try with resources reduces length of the code because it avoids usage of finally block.


Nested try/catch block
---------------------- 
A try/catch block within try or catch or finally blocks is known as nested try catch

syntax
------
try
{
   try{
   //
   }
   catch(ExceptionType e)
   {
   }
}
catch(ExceptionType e)
{
     try{
   //
   }
   catch(ExceptionType e)
   {
   }
}
finally
{
   try{
   //
   }
   catch(ExceptionType e)
   {
   }
}

throw                            throws
-----                            ------
throws exception              throws exception from a method
from a try block
programmatically

used to userdefined           used to throw checked exceptions
exceptions


syntax                           syntax
------                          --------
throw new ExceptionType("");   accessmodifier returntype methodname()                                throws  ExceptionType
                               {
                                 //
                               }


Wrapper classes
---------------
A wrapper class is a class which is used to represent primitives as objects i,e we can convert primitives to objects using wrapper classes.

We need to convert primitives to objects because there are situations where we need to use only objects like while working with collections we should use only objects.

For each primitive we have one wrapper class in java.

Primitive                wrapper
--------                 -------
char                     Character
byte                     Byte
short                    Short
int                      Integer
long                     Long
float                    Float
double                   Double
boolean                  Boolean


All the wrapper classes are available in java.lang.*

AutoBoxing and unboxing
-----------------------

Autoboxing
----------
The process of converting primitives to  objects is known as boxing.

Converting primitive to object automatically is known as autoboxing.


Program
-------
class Test
{
  public static void main(String args[])
  {
      int a=10;//primitive
      Object obj=a;//object
      System.out.println(obj);
  }
}



Autounboxing
------------
converting object to primitive  is known as unboxing.

Converting object to primitive automatically is known as Autoautoboxing.

Program
-------
class Test
{
  public static void main(String args[])
  {
      Object obj=10;
      int a=(int)obj;
      System.out.println(a);
  }
}


Methods of Wrappers
-------------------
parseXXX()
xxxValue()
valueOf()
toString()


Heirarchy of Wrappers
---------------------
Object 
|
Number
|
Byte  Short  Integer Long  Float Double

All warapper classes implements Serializable interface.

parseXXX()
----------
This method is used to convert a String type of data into required primitive.

Every Wrapper class is having one parseXXX() method.


public static byte parseByte(String);
public static short parseShort(String);
public static int parseInt(String);
public static float  parseFloat(String);
public static double parseDouble(String);
public static long parseLong(String);
public static boolean parseBoolean(String);
mn
All the parseXXX() methods are static methods.

All the parseXXX() methods throws checked exception NumberFormatException.


CommandLine arguments
---------------------
These accepts values from command prompt.

The parameter to main() method in java is known as command line argument i,e String args[].


How to pass values from command prompt to command line arguments
----------------------------------------------------------------
syntax
------
java ClassName/fileName  value1 value2 value3 .....

ex:
java Test 10 20 30


Here we should pass command line arguments from command prompt while executing a java program.

Here First parameter is copied to args[0].
Here second parameter is copied to args[1].
Here Third parameter is copied to args[2].

and so on.

i,e 10 is copied to args[0]
    20 is copied to args[1]
    30 is copied to args[2]


The default size of command line argument is zero.

i,e the size of String args[] is zero(0) by default.

When we pass values from command prompt automatically size increases and the size of String args[] will be no of values we are passing from command prompt.

Program
-------
class Test
{
   public static void main(String args[])
   {
       int a=Integer.parseInt(args[0]);
       System.out.println(a);
   }
}
              

save as Test.java

compile
-------
javac Test.java

Run
---
java Test 10.

Program
-------
class Test
{
  public static void main(String args[])
  {
       int a=Integer.parseInt(args[0]);
       int b=Integer.parseInt(args[1]);
       int c=a+b;
       System.out.println(c);
   }
}

Note:we should pass proper string while passing to parse method otherwise it leads to NumberFormatException.

xxxValue()
----------
This method is used to convert a wrapper object to required primitive.


Methods
-------
public byte byteValue();
public short shortValue();
public int   intValue();
public long longValue();
public float floatValue();
public double doubleValue();
public boolean booleanValue()
public char charValue();

These methods are used to convert a wrapper object to its equivalent primitive automatically.They perform auto unboxing.

Program
-------
class Test
{
  public static void main(String args[])
  {
      
      Integer i=new Integer(10);//Autoboxing
      int j=i.intValue();//Autounboxing
       System.out.println(i);
       System.out.println(j);

 }
}


valueOf()
---------
This method is used to perform autoboxing i,e it converts a primitive to its equivalent wrapper object.

It is represented in the following forms

public static Integer valueOf(int);
This method converts a primitive(int) to wrapper(Integer).

public static Integer valueOf(String);
This method converts a integer string to wrapper(Integer).

similarly every wrapper class has  valueOf() method as shown below
public static Byte valueOf(byte);
public static Byte valueOf(String);
public static Short valueOf(short);
public static Sort valueOf(String);
public static Long valueOf(long);
public static Long valueOf(String);
public static Float valueOf(float);
public static Float valueOf(String);
public static Double valueOf(double);
public static Double valueOf(String);
public static Boolean valueOf(boolean);
public static Boolean valueOf(String);

Program
-------
class Test
{
  public static void main(String args[])
  {
       double d=10.5;
       Double val=Double.valueOf(d);
       System.out.println(val);   
   
  }
}

Program
-------
class Test
{
  public static void main(String args[])
  {
       String d="10.5";
       Double val=Double.valueOf(d);
       System.out.println(val);   
   
 }
}


toString()
----------
This method is used to convert any wrapper to String type


syntax
------
public String toString();

Program
-------
class Test
{
  public static void main(String args[])
  {
      Boolean b=true;
      String s=b.toString();   
      System.out.println(s);
    
 }
}

Dont use methods of wrapper convert primitive to wrapper.
Note:
we can also convert primitive to wrapper object or a numeric String to a warpper by using constructors of Wrapper classes.

Constructors summary
--------------------
Byte class
   Byte(byte)
   Byte(String);

Short class
   Short(short);
   Short(String)

Integer class
   Integer(int)
   Integer(String)

Long class
  Long(Long)
  Long(String)

Float class
  Float(float);
  Float(double);
  Float(String);

Double class
  Double(double)
  Double(String)

Boolean class
  Boolean(boolean)
  Boolean(String)

Character class
  Character(char)



Collection Framework
--------------------
Framework
---------
A framework is collection of interfaces,classes and enum.


Arrays
------
Collection of homogenous elements.

Arrays are type safe.

Performance is good.

Arrays holds both primitives and objects.


Limitations
-----------
i)Arrays are static in nature i,e fixed in size i,e they are not automatically growable and shrinkable.

ii)Arrays are not heterogenous.

iii)No predefined method support to work with arrays.

Collection
----------
A collection is representing group of objects as a single entity.

A collection stores only objects.

Collection allows heterogenous elements.

Collection is dynamic i,e automatically growable and shrinkable.

Collection provides predefined method support.


Limitations
-----------
Collection is not type safe.

Performance is low because of convertions internally from primitive to object and object to primitive.


if we want work with built-in datastructures Collection framework provides classes and interfaces to work with datastructres.

Collection framework is used to process data while performing database operations in java project,it is also to process huge data in general appliactions(Non-database applications).


Collection interface
--------------------
A Collection is root interface of all collections.

Collection interface consists of methods which are common for the entire Collections. 

Collections is an utility class which consists of utilty methods.

All Collections are available in java.util.*


Methods summary of Collection interface
---------------------------------------
  public abstract int size(); 
   returns size of collection
    
  public abstract boolean isEmpty();
  returns true if collection is empty otherwise false.

  public abstract boolean contains(java.lang.Object);
  checks whether an object is available in a collcetion or not returns   true if it available otherwise false.

  public abstract java.util.Iterator<E> iterator();
  This method returns iterator object.

  public abstract java.lang.Object[] toArray();
  convert collection to Array.

  public abstract boolean add(java.lang.Object);
  adds an objectto collection.

  public abstract boolean remove(java.lang.Object);
  remove an object from collection.

  public abstract boolean containsAll(java.util.Collection<?>);
  checks whether a Collection is available in another collection or not returns true if it available otherwise false.
  
  public abstract boolean addAll(java.util.Collection<? extends E>);
  This is used to add a Collection to another collection.

  public abstract boolean removeAll(java.util.Collection<?>);
  This is used to remove a collection object from a another collection.

  public abstract boolean retainAll(java.util.Collection<?>);
  

  public abstract void clear();
  clears collections. 

  public abstract boolean equals(java.lang.Object);
  Used to check whether 2 objects are same or not returns true if both the objects are same otherwise false.

  public abstract int hashCode();
  returns hashCode of a collection.



List
----
It is child interface of collection.

Properties
----------
List is dynamic i,e it is growable and shrinkable.

List is heterogenous.

List allows duplicate values.

List preserves insertion order.

List allows null values.


Implementation classes of List
------------------------------
A List is implemented in the following classes.

i)ArrayList
ii)LinkedList
iii)Vector
iv)Stack



Collection 
^
|
List
|           |           |
ArrayList   LinkedList  Vector
                         |
                        Stack


Methods of List interface
-------------------------
 public abstract Object get(int);
 It is used to get an object from List.

 public abstract Object set(int, Object);
 used to set or update an object in a List

 public abstract void add(int, Object);
 Adds an object at a given index.

 public abstract Object remove(int);
 remove an object at a given index.

 public abstract int indexOf(java.lang.Object);
 returns index of an object.


ArrayList
---------
It is implementation class of List interface

The underlying datastructure of ArrayList is dynamic array.


Constructors
------------
 public java.util.ArrayList(int);
 public java.util.ArrayList();
 public java.util.ArrayList(java.util.Collection<? extends E>

The default capacity of  ArrayList is 10.

ArrayList is introduced in 1.2 version.

ArrayList implements the following interfaces

i)RandonAccess.
ii)Serializable.
iii)Cloneable.


RandomAccess
------------
This interface makes ArrayList efficient in performing retrieval operation.


Serializable
------------
If we implement Serializable interface then we can write an object to a file or we can send an object through a network.


Cloneable
---------
This allows us to create an exact copy of an object which we call this as cloning.



The above 3 interfaces are called marker interfaces.

Marker interface
----------------
A marker interface is an interface without any methods.

A marker interface provides additional capability to objects.

public interface RandomAccess
{
}

Program
-------
package com.manohar.java;

import java.util.ArrayList;

public class ArrayListDemo {
	public static void main(String[] args) {
        ArrayList l=new ArrayList();
        l.add(10);
        l.add(20);
        l.add(30);
        l.add(40);
        l.add("vidhatri");
        l.add(50);

        Sop(l);
        
        //displaying size
        System.out.println(l.size());//5
        
        //adding object at a given index
        l.add(3,35);
        System.out.println(l);
        
        //displaying size
        System.out.println(l.size());//6
       
        
        //remove based on index
        l.remove(4);
        System.out.println(l);
        
        //displaying size
        System.out.println(l.size());//5
        
        
        //remove based on object
        l.remove(new Integer(20));
        System.out.println(l);
        
        
        //displaying size
        System.out.println(l.size());//5

        //contains
        System.out.println(l.contains(new Integer(50)));
        
        //toArray
        Object obj[]=l.toArray();
        for(int i=0;i<obj.length;i++){
        	System.out.println(obj[i]);
        }
        
        //get()
        System.out.println("get "+l.get(2));
        
        //set
        l.set(2,new Integer(70));
        System.out.println(l);
        
        //indexof
        System.out.println(l.indexOf(30));
        
        //lastindexof
        System.out.println(l.lastIndexOf(70));

       //isEmpty
       System.out.println(l.isEmpty());
        
        //retains
        l.clear();
        System.out.println(l);

    }
}

i)add() method is represented in 2 forms

add(Object)-->This method will add an object sequentially in a collection.

add(int,object)-->This method add an element at a given index,here the object in the existing location is moved to next location from current location.

set(int,object)->it replaces old element with new element.


remove(Object)-->this method removes an object from a List directly.

remove(int)-->this removes an object based on index,here we should pass int as a value,if the size exceeds it leads to an exception

IndexOutOfBoundsException


case1
-----
package com.manohar.java;

import java.util.ArrayList;

public class ArrayListDemo {
	public static void main(String[] args) {
		ArrayList l = new ArrayList();
		l.add(10); 
		l.add(20);
		l.add(30);
		l.add(40);
		l.add(50);
		for(int i=0;i<l.size();i++)
		{
			 System.out.println(l.get(i));
		}

	}
}



case2
-----
package com.manohar.java;

import java.util.ArrayList;

public class ArrayListDemo {
	public static void main(String[] args) {
		ArrayList l = new ArrayList();
		l.add(10); 
		l.add(20);
		l.add(30);
		l.add(40);
		l.add(50);
		for(int i=0;i<l.size();i++)
		{
			Object obj = l.get(i);
			 System.out.println(obj);
		}

	}
}



case3
-----
package com.manohar.java;

import java.util.ArrayList;

public class ArrayListDemo {
	public static void main(String[] args) {
		ArrayList l = new ArrayList();
		l.add(10); 
		l.add(20);
		l.add(30);
		l.add(40);
		l.add(50);
		for(int i=0;i<l.size();i++)
		{
			 Object obj = l.get(i);
			 Integer  integer=(Integer)obj;
			 System.out.println(integer);
		}

	}
}

Reversing ArrayList.
Sorting ArrayList.
searching for an element from ArrayList.
removing duplicates  elements from an ArrayList.


case4
-----
package com.manohar.java;

import java.util.ArrayList;

public class ArrayListDemo {
	public static void main(String[] args) {
		ArrayList l = new ArrayList();
		l.add(10); 
		l.add(20);
		l.add(30);
		l.add(40);
		l.add(50);
		for(int i=0;i<l.size();i++)
		{
			 Object obj = l.get(i);
			 Integer  integer=(Integer)obj;
			 int x=integer.intValue();
			 int y=integer;
			 System.out.println(x);
			 System.out.println(y);
		}

	}
}

case5
-----
package com.manohar.java;
import java.util.ArrayList;
public class ArrayListDemo {
	public static void main(String[] args) {
		ArrayList l = new ArrayList();
		l.add(10); 
		l.add(20);
		l.add(30);
		l.add(40);
		l.add(50);
		for(int i=0;i<l.size();i++)
		{
			int val=(int)l.get(i);
			System.out.println(val);
		}

	}
}

Program
-------
package com.manohar.java;

import java.util.ArrayList;

public class ArrayListDemo {
	public static void main(String[] args) {
		ArrayList l = new ArrayList();
		l.add(10);
		l.add(11);
		l.add(20);
		l.add(21);
		l.add(30);
		l.add(40);
		l.add(50);
		for (int i = 0; i < l.size(); i++) {
			int val = (int) l.get(i);
			if (val % 2 == 0) {
				System.out.println(val);
			}
		}

	}
}

case7
-----
We can apply casting for related objects otherwise it leads to ClassCastException.
package com.manohar.java;

import java.util.ArrayList;

public class ArrayListDemo {
	public static void main(String[] args) {
        Object obj=10.6;
        int val=(int)obj;
        System.out.println(val);
}
}

Output
------
Exception in thread "main" java.lang.ClassCastException: java.lang.Double cannot be cast to java.lang.Integer

Program
-------
package com.manohar.java;

import java.util.ArrayList;
import java.util.Scanner;

public class ArrayListDemo {
	public static void main(String[] args) {
		ArrayList l = new ArrayList();
		l.add(10);
		l.add(11);
		l.add(20);
		l.add(21);
		l.add(30);
		l.add(40);
		l.add(50);
		System.out.println("enter val");
		int val=new Scanner(System.in).nextInt();
		
		boolean b=l.contains(val);
		if(b){
			int index=l.indexOf(val);
			System.out.println(index);
			System.out.println(l.get(index));
		}
		else{ 
			System.out.println("element not found");
		}
		

	}
}


tostring()
equals()
hashCode()

toString()
----------
toString() is used to convert an object to a String object.

toString method is available in Object class.

whenever we print reference of object the hashcode of an object is displayed in hexadecimal form.

package com.manohar.java;

class  Test
{
	
}
public class ArrayListDemo {
	public static void main(String[] args) {
       Test t=new Test();
       System.out.println(t);//line1
}
}

output
------
com.manohar.java.Test@15db9742

Here the hashcode is represented in hexa form as
packagename.classname@hexacode.

In the above at line we are printing reference of Test class.

Whenever we print reference of an object the print statement internally calls toString() of object which returns hashcode.


we can override toString() method and display userdefined hascode as per program requirement.

Program
-------
package com.manohar.java;

class  Test
{
	public String toString()
	{
		Integer val=(int) (Math.random()*1000);
		return val.toString();
               //return (int)(Math.random()*100000)+"";
	}
}
public class ArrayListDemo {
	public static void main(String[] args) {
       Test t=new Test();
       System.out.println(t);
}
}

random() generates a random value from 0.1 to 0.9.

output
------
78890

hashCode()
----------
A hashCode() method returns integer representation of a hashcode().

It is available in object class.

package com.manohar.java;
class Test {

}
public class ArrayListDemo {
	public static void main(String[] args) {
		Test t = new Test();
		System.out.println(t.hashCode());

	}
}

output
------
366712642

toString() method of object class calls hashCode()  internally and this is converted to String form and returned by toString() method.

A developer also can override hashCode() method and call it from toString().

Program
-------
package com.manohar.java;
class Test {
	public int hashCode(){
		double val=Math.random()*1000000;
		return (int)val;
	}
	public String toString()
	{
		return Integer.toHexString(hashCode())+"";
	}

}

public class ArrayListDemo {
	public static void main(String[] args) {
		Test t = new Test();
		System.out.println(t);

	}
}


output
------
c6ed0


we can convert a hashcode into hexa\octal\binary by using methods in wrapper class.They are

toHexString()-->converts a number to hexa decimal String.
toOctalString()-->converts a number to octal String.
toBinaryString()-->converts a number to  binary String.


equals()
--------
A equals is used to check whether 2 objects are equal or not,if equal returns true otherwise false.

It is available in Object class.
we can override equals as per program requirement.

Object class equals method is used to compare references but most of the predefined class override equals method for content(data) comparision.

ex:
String 
All Wrappers
etc
override equals method for content comparision.
StringBuffer class equals performs refernce comparsion.

Program
-------
package com.manohar.java;
public class ArrayListDemo {
	public static void main(String[] args) {
                //case1
		String s1="satya";
		String s2="manohar";
		System.out.println(s1.equals(s2));


                //case2		
		StringBuffer  b1=new StringBuffer("satya");
		StringBuffer  b2=new StringBuffer("satya");
		System.out.println(b1.equals(b2));
		
	}
}


LinkedList
----------
LinkedList implements List,Serializable,Cloneable,Queue

LinkedList is best for perorming insert operation and worst for performing retrieval operation.

It  follows same properties of List.


LinkedList Specific Methods
---------------------------
addFirst()
addLast()
removeFirst()
removeLast()
getFirst()
getLast()

The underlying datatstructure if LinkedList is double LinkedList.

It is introduced in 1.2 version.

Constructors
------------
LinkedList()

   This creates an empty list.

LinkedList(Collection);
 
   This accepts any collection.


Program
------
package com.manohar.java;

import java.util.LinkedList;

public class LinkedListDemo {
	public static void main(String[] args) {
		LinkedList list = new LinkedList();

		list.add(10);
		// Adds element as a first element
		list.addFirst(20);
		// Adds eleement as a Last element
		list.addLast(30);
		list.add(40);
		list.add(50);
		list.add(60);

		// get based on index
		System.out.println(list.get(1));
		// get first element
		System.out.println(list.getFirst());
		// get last element
		System.out.println(list.getLast());

		System.out.println(list);

		// remove based on object
		System.out.println(list.remove(1));

		// remove First
		System.out.println(list.removeFirst());

		// remove Last
		System.out.println(list.removeLast());

		System.out.println(list);

	}

}
output
------
10
20
60
[20, 10, 30, 40, 50, 60]
10
20
60
[30, 40, 50].


Vector
------
Vector is same as ArrayList  with the following differences.

ArrayList                         Vector
----------                    --------------
i)Not synchronized.           i)Synchronized.
ii)Not thread safe            ii)thread safe
iii)Best at performance       iii)Low at performance.
iv)1.2 version                 iv)1.0 version.



Note:
Vector is a legacy class i,e it is introduced in 1.0 version of java.


It consists of the following legacy methods like

i)addElement()
ii)removeElement()
iii)addAllElements())
iv)capacity()

etc

Costructors
------------
Vector()
creates an empty Vector object with a default capacity 10.

Vector(Collection<? extends E> c)
This Constructor accepts any type of Collection

Vector(int initialCapacity)
creates an empty Vector object with a customized capacity.


Vector(int initialCapacity, int capacityIncrement)
creates an empty Vector object with a customized capacity and fill ratio.

We can calculate the load factor of ArrayList or Vector by using the formula 

(initialcapacit*3/2)+1

10*3/2+1

16

16*3/2+1

25

The underlying datastructure of Vector is dynamic array.

Program
-------
package com.manohar.java;

import java.util.Vector;

public class VectorDemo {
	public static void main(String[] args) {
		Vector  vector=new Vector();
		System.out.println(vector.capacity());
		vector.addElement(10);
		vector.addElement(20);
		vector.addElement(30);
		vector.addElement(40);
		vector.addElement(10);
		System.out.println(vector.capacity());
		
		for(int i=0;i<vector.size();i++){
			System.out.println(vector.get(i));
		}
		System.out.println(vector);
	}

}



Vector is also best fit for retrieval operation because it also implements 
RandomAccess interface apart from List,Serializable,Cloneable.


Stack
-----
It is a child class of Vector.

It is introduced in 1.0 version


stack follows a principle Last in fisrt out[LIFO].

Methods
-------
  public java.util.Stack(); 
   creates a stack with empty list.

  public Object push(E);
  Adds an object to Stack.

  public synchronized Object pop();
  remove an object from Stack and returns.

  public synchronized Object peek();
  returns the top element.
  
  public boolean empty();
  checks whether a stack is empty.

  public synchronized int search(java.lang.Object);
  searches whether an element is available in stack or not. 
  returns position of the element from top ,if it is available in stack 
  otherwise it returns -1.

In Stack insertion and deletion is done through only one end called top.

Program
-------
package com.manohar.java;

import java.util.Stack;

public class StackDemo {
public static void main(String[] args) {
	Stack  stack=new Stack();
	stack.push(10);
	stack.push(20);
	stack.push(30);
	stack.push(40);
	stack.push(50);
	stack.push(60);
	
	System.out.println(stack);
	System.out.println(stack.pop());//60
	System.out.println(stack);//
	System.out.println(stack.peek());//50
	System.out.println(stack);
	System.out.println(stack.empty());//false
	System.out.println(stack.search(new Integer(45)));
	
}
}

output
------
[10, 20, 30, 40, 50, 60]
60
[10, 20, 30, 40, 50]
50
[10, 20, 30, 40, 50]
false
-1

Iterators
---------
An iterator performs a repititive task.


Two types of iterators
i)control statements
ii)Collecton

Iterators in Control statements

while
do-while
for


Iterators in collections

for-each.
Enumeration.
Iterator.
ListIterator.


for-each
--------
It is applicable on both static collection and dynamic collelction.

syntax
------

for(datatype  destination:source)
{
//statements
}

Here source must be collection type i,e either array or collection

Every time for-each is iterated one object\value from source is copied to local variable(destination).


Program
-------
package com.manohar.java;
public class ForEachDemo1 {
public static void main(String[] args) {
		
String s[]={"java","hadoop","salesforce","devops"};
		
for(String str:s){
System.out.println(str);
}

}
}


Program
-------
package com.manohar.java;
import java.util.ArrayList;
public class ForEachDemo1 {
	public static void main(String[] args) {
		ArrayList list=new ArrayList();
		list.add(10);
		list.add(20);
		list.add(30);
		list.add(40);
		list.add(50);
		
		for(Object obj:list){
			System.out.println(obj);
		}
	}

}


Limitations of for-each
-----------------------
i)for-each doesn't provide predefined method support.
ii)for-each is used to perform only read operation.
iii)for-each is a uni directional cursor i,e it performs iteration only in forward direction.


Iterators in collections
------------------------
Collection framework provides predefined iterators to perfrom iteration on collection objects.

They are 

i)Enumeration.[inteface]
ii)Iterator.[interface]
iii)ListIterator.[interface]

All the iterators provides predefined method support in Collection Framework.

All the above 3 iterators are available in java.util.* package

Enumeration 
-----------
It is introduced in 1.0 version.

It is applicable only on Vector and Stack because Enumeration is a legacy iterator,Vector and Stack are also legacy classes.

It is read-only/forward only cursor.

Method summary
--------------
  public abstract boolean hasMoreElements();
     This method checks whether an object is available in the collection or not and returns true if the object exists otherwise false.       
   
public abstract Object nextElement();
  This method moves the cursor to next element and returns that element.


How to get Enumeration object on Vector and Stack
-------------------------------------------------
we use the method elements() avaialble in Vector and Stack to get Enumeration object of Vector and Stack.

syntax
------
public Enumeration elements();

syntax
------
Enumeration enumeration=reference.elements();

Here reference is reference of a Vector or Stack.

Case study
----------
create Vector object and add objects
Get Enumeration object
Iterate using while

syntax
------
while(enumeration.hasMoreElements()){
  //enumeration.nexElement();
}



Program
-------
package com.manohar.java;
import java.util.Enumeration;
import java.util.Vector;
public class ForEachDemo1 {
	public static void main(String[] args) {
		Vector list=new Vector();
		list.add(10);
		list.add(20);
		list.add(30);
		list.add(40);
		list.add(50);
		
		//step2
		Enumeration e=list.elements();
		
		//step3
		while(e.hasMoreElements()){
			System.out.println(e.nextElement());
		}
		
	}

}


Iterator
--------
It perfoms a repetitive task.

It is universal cursor i,e it is applicable on all Collections.

It peforms both read and remove operations.

It is forward only cursor.

1.2 version.

Method summary
--------------
  public abstract boolean hasNext();
      This method checks whether an object  exist in collection or not ,returns true if object is available otherwise false. 
   
public abstract E next();
 This method moves cursor to the next element in collection and returns that element.

public void remove();
remove an element from collection

public void forEachRemaining(java.util.function.Consumer<? super E>);

How to get iterator object of collection
------------------------------------
we get iteartor object of collection by using method 
iterator() available in Collection interface.
 

Method signature
----------------
public Iterator iterator();


Getting iterator object
-----------------------
Iterator iterator=reference.iterator();

Here reference is reference of a collection class.

syntax
------
while(iterator.hasNext())
{
    //
    iterator.next();
}

Program
-------
package com.manohar.java;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedList;

public class ForEachDemo1 {
	public static void main(String[] args) {
		ArrayList list = new ArrayList();
		list.add("java");
		list.add("coffee");
		list.add("bru");
		list.add("taj");
		list.add("iphone");
		list.add("umbrealla");

		Iterator iterator = list.iterator();

		while (iterator.hasNext()) {
			String string = (String) iterator.next();

			if (string.startsWith("a") || string.startsWith("e") || string.startsWith("i") || string.startsWith("o")
					|| string.startsWith("u") || string.startsWith("A") || string.startsWith("E")
					|| string.startsWith("I") || string.startsWith("O") || string.startsWith("U")) {

				iterator.remove();

			}

		}
		System.out.println(list);

	}

}


ListIterator
------------
It is an interface.

It is applicable only on List classes.

A ListIterator is a child interface of Iterator.

ListIterator is the most powerful cursor among the cursors because it is bidirectional also we can perform read,write,update,remove operations using ListIterator.


Method summary
--------------
 public abstract boolean hasNext();
   checks whether an object exits in collection or not,returns true if the object is available otherwise false. 

 public abstract Object next();
  Moves cursor next object and returns that object.

 public abstract boolean hasPrevious()
    
checks whether an object exits in collection or not,returns true if the object is available otherwise false. 

public abstract Object previous();
Position cursor to previous object and returns that object.

public abstract int nextIndex();
returns the next index of an object.

public abstract int previousIndex();
returns the previous index of an object.

public abstract void remove();
remove an object from collection.

public abstract void set(Object);
update an object in a collection.

public abstract void add(Object);
Adds an object to a collection.


How to get ListIterator object
------------------------------
We use the method listIterator() available in all List classes.

Method signature
----------------
public ListIterator listIterator();


syntax
------
ListIterator iterator=reference.listIterator();

ListIterator is applicable only on List implementation classes.

Program
-------
package com.manohar.java;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.util.ArrayList;
import java.util.ListIterator;


public class ArrayListDemo {
	public static void main(String[] args) {
      ArrayList list=new ArrayList();
      list.add(10);
      list.add(20);
      list.add(30);
      list.add(40);
      list.add(50);
      
      //step2
      ListIterator iterator=list.listIterator();
      
      while(iterator.hasNext()){
    	  
    	  System.out.println(iterator.next());
      }
      
  }
}



Program
-------
package com.manohar.java;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.util.ArrayList;
import java.util.ListIterator;


public class ArrayListDemo {
	public static void main(String[] args) {
      ArrayList list=new ArrayList();
      list.add(10);
      list.add(20);
      list.add(30);
      list.add(40);
      list.add(50);
      
      //step2
      ListIterator iterator=list.listIterator(list.size());
      
      while(iterator.hasPrevious()){
    	  
    	  System.out.println(iterator.previous());
      }
      
   }
}

Note:
   we should pass size of collection as a parameter  to listIterator() so that we can perform navigation or iteration in both the directions.


Program
-------
package com.manohar.java;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.util.ArrayList;
import java.util.ListIterator;

import com.sun.corba.se.spi.orbutil.fsm.State;

public class ArrayListDemo {
	public static void main(String[] args) {
      ArrayList list=new ArrayList();
      list.add(1);
      list.add(2);
      list.add(20);
      list.add(30);
      list.add(400);
      list.add(500);
      
      //step2
      ListIterator iterator=list.listIterator(list.size());
      
      while(iterator.hasPrevious()){
    	  int x=(int)iterator.previous();
    	  
    	  if(x>=10&&x<100){
    		  iterator.remove();
    	  }
    	  
      }
      
      
      System.out.println(list);
	
		
	}
}


Program
-------
package com.manohar.java;

//1-10
//After even no -->Add a string of that number
//After odd no -->replace that no with its String name
import java.util.ArrayList;
import java.util.ListIterator;

public class ArrayListDemo {
	public static void main(String[] args) {
		ArrayList list = new ArrayList();
		list.add(1);
		list.add(2);
		list.add(7);
		list.add(8);
		list.add(5);

		// step2
		ListIterator iterator = list.listIterator();
	
		while (iterator.hasNext()) {
			int x = (int) iterator.next();

			if (x % 2 == 0) {
				if (x == 2) {
					iterator.add("Two");
				} else if (x == 4) {

					iterator.add("Four");
				} else if (x == 6) {
					iterator.add("six");
				} else if (x == 8) {
					iterator.add("Eight");

				}
			} else {
				if (x == 1) {
					iterator.set("one");
				} else if (x == 3) {

					iterator.set("Three");
				} else if (x == 5) {
					iterator.set("five");
				} else if (x == 7) {
					iterator.set("seven");

				} else if (x == 9) {
					iterator.set("nine");

				}

			}
		}

		System.out.println(list);

	}
}

Note:
While iterating a collection using iterator we should perform operations on collection object using methods of iterator otherwise it leads to "ConcurrentModificationEXception".



How to get synchrinized version of ArrayList
--------------------------------------------
we can get synchronized version any List implementation by using the method synchronizedList() available in Collections class.

Method signature
----------------
public static List  synchronizedList(List);


Example
-------
ArrayList list=new ArrayList();
list.add(10);
list.add(20);
list.add(30);


List  list=Collections.synchronizedList(list);


Set collection
--------------
It is a child interface of Collection

Set heirarchy
-------------

Collection
 |
Set--------------------------------
 |             |              |
HashSet    LinkedHashSet    SortedSet
                              |
                            NavigableSet
                              |
                             TreeSet


dynamic                  yes

heterogenous\homogenous  heterogenous except TreeSet

insertion order          Not preserved except                          LinkedHashSet

duplicates               Are not allowesd

null insertion            Except TreeSet null insertion is                           possible for all Set classes.


HashSet
-------
Impl class of Set

It implments Set,Serializable,Colneable,Collection.

It is introduced in 1.2 version.

Underlying datastructure of HashSet is Hashtable

It is heterogenous.

Constructors of HashSet
-----------------------

HashSet()
creates empty HashSet() with initial default capacity 16 and loadfactor 0.75.


HashSet(Collection)
This accepts any collection as a parameter.

HashSet(int)
creates empty HashSet with userdefined capacity.

HashSet(int,float)
creates empty HashSet with userdefined capacity and loadfactor.


Program
-------
package com.manohar.java;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;

public class DuplicateRemoveDemo {
	public static void main(String[] args) {

		HashSet set = new HashSet();
		set.add(10);
		set.add(11);
		set.add(20);
		set.add(21);
		set.add(30);
		set.add(40);

		Iterator iterator = set.iterator();
		while (iterator.hasNext()) {
			int x = (int) iterator.next();

			if (x % 10 == 0) {
				System.out.println(x);
			}
		}

	}

}

display numbers starting with 1

display numbers ending with 1


LinkedHashSet
-------------

Introduced in 1.4 version.

It is same as HashSet except the underlying datastructure.

The unuderlying datastructure of LinkedHashSet is
LinkedList and Hashtable.

LinkedHashSet preserves insertion order.

constructor summary
-------------------
LinkedHashSet()
creates empty HashSet() with initial default capacity 16 and loadfactor 0.75.


LinkedHashSet(Collection)
This accepts any collection as a parameter.

LinkedHashSet(int)
creates empty HashSet with userdefined capacity.

LinkedHashSet(int,float)
creates empty HashSet with userdefined capacity and loadfactor.



Program
-------
package com.manohar.java;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;

public class DuplicateRemoveDemo {
	public static void main(String[] args) {

		LinkedHashSet set = new LinkedHashSet();
		set.add(10);
		set.add(11);
		set.add(20);
		set.add(21);
		set.add(30);
		set.add(40);

		Iterator iterator = set.iterator();
		while (iterator.hasNext()) {
			int x = (int) iterator.next();
			System.out.println(x);
		}

	}

}

output
------
10
11
20
21
30
40

Usage
-----
If we want to avoid duplicates and insertion order must be preserved then choose LinkedHashSet,if we don't
want to preserve insertion order and if we want to remove duplicates then choose HashSet.



SortedSet
---------
A SortedSet is an interface.

SortedSet is used to avoid duplicates and sort elements of collection according to natural sorting order(ascending order).

It is child interface of Set.


It is introduced in 1.2 version.

Method summary
--------------
 public abstract java.util.SortedSet<E> subSet(Object, Object);
  returns set elements from starting object and upto ending object excluding ending object.
  
 public abstract java.util.SortedSet<E> headSet(E);
 returns head part of an collection.
 
 public abstract java.util.SortedSet<E> tailSet(E);
 returns tail part of a collection.
  
 public abstract E first();
 returns first element of a collection.

 public abstract E last();
 returns last element of a collection.

 public java.util.Spliterator<E> spliterator();
 similar to iterator.


 TreeSet
 -------
 It is implementation class of Set,SortedSet,NavigableSet,Cloneable,Serializable.

 If we want to avoid duplicates and sort elements according to natural sorting order then we should use TreeSet.

It is dynamic.

It is homogenous,if we try to insert heterogenous elements it leads to ClassCastException.

It doesn't allow duplicates.

Insertion order not preserved.

null insertion is not allowed in TreeSet,if we try to insert null values it leads to NullPointerException.

In the previous versions null insertion is possible in empty TreeSet  but from 1.7 version onwards null insertion is not possible even in empty TreeSet also.

Program
-------
package com.manohar.java;

import java.util.TreeSet;

public class TreeSetDemo {
	public static void main(String[] args) {
		TreeSet set=new TreeSet();
		set.add(10);
		set.add(5);
		set.add(20);
		set.add(15);
		set.add(19);
		
		System.out.println(set);
		
		System.out.println(set.subSet(5,15));//5,10
		System.out.println(set.headSet(15));//5,10
		System.out.println(set.tailSet(15));//5,10
		System.out.println(set.first());
		System.out.println(set.last());
		
}
}
output
------
[5, 10, 15, 19, 20]
[5, 10]
[5, 10]
[15, 19, 20]
5
20


NavigableSet
------------
It is child interface of SortedSet.

It provides methods to perform navigation of data.

Introduced in 1.6 version.

Method Summary
--------------
 public abstract Object lower(Object);
 returns lower element of an object i,e element less than  the object.

 public abstract Object floor(Object);
 returns lower limit of an Object.

 public abstract Object ceiling(Object);
 returns upper limit of an Object.

 public abstract Object higher(Object);
 returns  an higer element of an object i,e element  greater than object.
 
 public abstract Object pollFirst();
 returns first element

 public abstract Object pollLast();
 returns last element.


 public abstract java.util.Iterator<E> iterator();
 public abstract java.util.NavigableSet<E> descendingSet();
 displays elements in descending order.


Program
-------
package com.manohar.java;

import java.util.TreeSet;

public class TreeSetDemo {
	public static void main(String[] args) {
		TreeSet set=new TreeSet();
		set.add(10);
		set.add(5);
		set.add(20);
		set.add(15);
		set.add(19);
		
		System.out.println(set);
		
		//methods of navigable set
		System.out.println(set.lower(15));//
		System.out.println(set.higher(15));//
		System.out.println(set.pollFirst());//
		System.out.println(set.pollLast());//
		System.out.println(set.floor(16));
		System.out.println(set.ceiling(18));
		System.out.println(set);
		
		
		//
		System.out.println(Math.floor(10.6));//
		System.out.println(Math.ceil(5.3));//
	
	}

}

Note1:
If we try to insert heterogenous elements in a TreeSet it leads to ClassCastException.

Note2:
If we add a null value to a TreeSet it leads to NullPointerException.

Note3:
descendingSet() returns elements of set in descending order.

TreeSet set=new TreeSet();
		set.add(10);
		set.add(5);
		set.add(20);
		set.add(15);
		set.add(19);
System.out.println(set.descendingSet());

Constructor summary of LinkedHashSet and TreeSet
------------------------------------------------
LinkedHashSet()
creates empty HashSet() with initial default capacity 16 and loadfactor 0.75.


LinkedHashSet(Collection)
This accepts any collection as a parameter.

LinkedHashSet(int)
creates empty HashSet with userdefined capacity.

LinkedHashSet(int,float)
creates empty HashSet with userdefined capacity and loadfactor.


TreeSet()
Creates empty tree set, sorted according to the natural ordering of its elements.

TreeSet(Collection<? extends E> c)
Used to copy elements of any other collection into TreeSet.

TreeSet(Comparator<? super E> comparator)
Creates a new empty tree set, and accepts as Comparator as a parameter.

TreeSet(SortedSet<E> s)
Creates a new tree and sorts elements according to SortedSet.

Underlying datastructure of TreeSet is Red-
black trees.


Comparable and Comparator interface
-----------------------------------
Comparable
----------
It is available in java.lang.*

If we want to go natural sorting then we should implement Comparable interface.

It consists of one method compareTo()

signature 
---------
public int comparaeTO(object);


How access compareTo()
----------------------

obj1.compareTo(obj2);

case 1:
returns zero if both objects are same.

case2:retuns a negative value of object1 is less than object2 i,e unicode difference.

case3:
retuns a positive value of object1 is greater than object2 i,e unicode difference.


Natural sorting in TreeSet 
--------------------------
Every time we add an element to TreeSet,jvm internally call compareTo() method to perform sorting of elements according to natural sorting order.

TreeSet set=new TreeSet();
	   set.add("A");
	   set.add("M");//"M".compareTo("A");+ve
	   set.add("B");//"B".compareTo("M");-ve
	                 // "B".compareTo("A");+ve
	           
	   System.out.println(set);


obj1-the latest element we add to TreeSet.

obj2-already existing object.

Note:
if -ve exchange of values happens in TreeSet

if +ve no need of any exchange.


Customized sorting int collections
----------------------------------
Comparator
----------
It is an interface available in java.util.* package.

We want to implement customized sorting then we should go for Comparator interface.

It consists of a method compare() 


steps for implementing customized sorting in Comparator
------------------------------------------------------
step1:Implement Comparator interface in a class.

accessmodifier class ClassName implements Comparator
{
}
step2:override compare() method and apply comparision logic in Comparator class.
ex:
class MyComparator implements Comparator {

	@Override
	public int compare(Object obj1, Object obj2) {
		String s1 = (String) obj1;
		String s2 = (String) obj2;
		return -s1.compareTo(s2);
	}
}
step3:Create TreeSet object and pass Comparator object as a parameter to the constructor of TreeSet.
ex:
// step1
MyComparator comparator = new MyComparator();
//step2
TreeSet set = new TreeSet(comparator);

Program
-------
package com.manohar.java;
//step1
import java.util.Comparator;
import java.util.TreeSet;
class MyComparator1 implements Comparator
{
	@Override
	public int compare(Object o1, Object o2) {
	  
		 String s1=(String)o1;
		 String s2=(String) o2;
		 return -s1.compareTo(s2);
	}
	
}
public class ComparatorDemo {
	public static void main(String[] args) {
		//step2
		MyComparator1  comparator1=new MyComparator1();
		
		//step3
		
		TreeSet set=new TreeSet(comparator1);
		set.add("samantha");
		set.add("deepika");
		set.add("priyanka");
		set.add("kajal");
		set.add("rasi");
		
		System.out.println(set);
	}

}

output
------
[samantha, rasi, priyanka, kajal, deepika].


Pojo[Plain old java object]
---------------------------
It is a simple java class with private properties and public setters and getters.

It must have a default constructor.

It must implement a serializable interface.


creating setters and getters
----------------------------
setter methods
--------------
A setter method used to set value a to property of a pojo.

syntax
------
public void setPropertyName(datatype varname)
{
   this.varname=varname;
}

getter methods
--------------
A getter method returns a value of a property.

syntax
------
public datatype getPropertyName()
{
    return varname;
}
example
-------
class  Employee implements Serializable
{
    private String empName;
    private int  empID;
    private double empSal;

    //
    public void setEmpName(String empName)
    {
       this.empName=empName;
    }

    public String getEmpName()
    {
       return empName;
    }

}

display details 3 employees
---------------------------
create 3 objects for pojo

set values for all objects using setters.

get values throgh getters.

creating Array of objects
------------------------
Arrays can store both primitives and objects.


Program to create array of objects
----------------------------------
package com.manohar.pojo;

public class Employee {
	//property declarations
	private String empName;
	private int empID;
	private double empSal;
	//creating setters and getters
	
}

package com.manohar.java;
import java.util.Scanner;
import com.manohar.pojo.Employee;
public class ArrayOfObjectsDemo {
public static void main(String[] args) {

//declaring array of references
Employee e[] = new Employee[2];//1
		
//creating objects
for(int i=0;i<e.length;i++){
e[i]=new Employee();//2
}
		
Scanner scanner = new Scanner(System.in);
// initializing all the objects
for (int i = 0; i < e.length; i++) {
System.out.println("enter name");
e[i].setEmpName(scanner.next());
System.out.println("enter id");
e[i].setEmpID(scanner.nextInt());
System.out.println("enter sal");
e[i].setEmpSal(scanner.nextDouble());
}
// displaying all the objects
for (int i = 0; i < e.length; i++) {
System.out.println(e[i].getEmpName());
System.out.println(e[i].getEmpID());
System.out.println(e[i].getEmpSal());
}
}

}

In the above code @line1 we are declaring Array of reference for Employee.

Whenever we declare an array by default it is initialized with default values.

similarly as Employee is a reference type it is initialized with null as shown in diagram.

Once we declare references we should initialize reference with objects as shown @line2 otherwise it leads to NullPointerException whenever perform operations on these null references.

we are initiazing all the obejcts using setters and getters as shown in loops.

Adding objects to collections and iterating objects from collection
----------
create 5 employee objects,initialize them using setters

add all the five employee objects to ArrayList/HashSet and display values from Employee by iterating collection.

package com.manohar.java;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.Scanner;

import com.manohar.pojo.Employee;

public class ArrayOfObjectsDemo {
	public static void main(String[] args) {

		// declaring array of references
		Employee e[] = new Employee[2];// line1

		// creating objects
		for (int i = 0; i < e.length; i++) {
			e[i] = new Employee();// line2
		}

		Scanner scanner = new Scanner(System.in);

		// initializing all the objects
		for (int i = 0; i < e.length; i++) {
			System.out.println("enter name");
			e[i].setEmpName(scanner.next());

			System.out.println("enter id");
			e[i].setEmpID(scanner.nextInt());

			System.out.println("enter sal");
			e[i].setEmpSal(scanner.nextDouble());

		}

		ArrayList list = new ArrayList();

		for (int i = 0; i < e.length; i++) {
			list.add(e[i]);
		}
		
		Iterator iterator=list.iterator();
		while(iterator.hasNext()){
			Employee employee=(Employee) iterator.next();
			System.out.println(employee.getEmpID());
			System.out.println(employee.getEmpName());
			System.out.println(employee.getEmpSal());
			
		}
		
		Iterator iterator2=list.iterator();
		while(iterator2.hasNext()){
			Employee e1=(Employee) iterator2.next();
			System.out.println(e1);
			
		}
}
}


Program
-------
package com.manohar.java;

import java.util.ArrayList;
import java.util.Iterator;

import com.manohar.pojo.Employee;

public class EmployeeTest {
	public static void main(String[] args) {
	     Employee  employee1=new Employee();
	    
	     employee1.setEmpID(1001);
	     employee1.setEmpName("manohar");
	     employee1.setEmpSal(10000.00);
	     
	     Employee  employee2=new Employee();
		    
	     employee2.setEmpID(1002);
	     employee2.setEmpName("prabhas");
	     employee2.setEmpSal(20000.00);
	     Employee  employee3=new Employee();
		    
	     employee3.setEmpID(1003);
	     employee3.setEmpName("mahesh");
	     employee3.setEmpSal(30000.00);
	     Employee  employee4=new Employee();
		    
	     employee4.setEmpID(1004);
	     employee4.setEmpName("pawan");
	     employee4.setEmpSal(40000.00);
	     Employee  employee5=new Employee();
		    
	     employee5.setEmpID(1005);
	     employee5.setEmpName("balayya");
	     employee5.setEmpSal(50000.00);
		
		//create collection
	     ArrayList list=new ArrayList();
	     list.add(employee1);
	     list.add(employee2);
	     list.add(employee3);
	     list.add(employee4);
	     list.add(employee5);
	     
	     Iterator iterator=list.iterator();
	     
	     while(iterator.hasNext()){
	    	 Employee employee=(Employee) iterator.next();
	    	 System.out.println(employee.getEmpID());
	    	 System.out.println(employee.getEmpName());
	    	 System.out.println(employee.getEmpSal());
	    	 
	    	 
	     }
	}

}


Sorting Userdefined using TreeSet
---------------------------------
If we want to add objects in TreeSet then the objects must be Comparable otherwise it leads to ClassCastException i,e the class must implement Comparable interface,objects created for such classes are only allowed in TreeSet.

Program
-------
Step1:create an Employee by implementing Comparable interface.

package com.manohar.java;
import java.io.Serializable;
public class Employee implements Serializable, Comparable {
	private String name;
	private int empID;
	private double empSal;
        //setters and getters

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public int getEmpID() {
		return empID;
	}

	public void setEmpID(int empID) {
		this.empID = empID;
	}

	public double getEmpSal() {
		return empSal;
	}

	public void setEmpSal(double empSal) {
		this.empSal = empSal;
	}

	@Override
	public int compareTo(Object obj) {
		Employee employee = (Employee) obj;
		if (this.empID < employee.empID) {
			return -1;
		} 
		else if (this.empID > employee.empID)
		{
			return +1;
		} else {
			return 0;
		}
	}
}
 


step2:creating Test class and passing Employee objects TreeSet whihc are sorting according to empid.

public class EmpTest {
	public static void main(String[] args) {

		Employee employee1 = new Employee();
		employee1.setEmpID(1);
		Employee employee2 = new Employee();
		employee2.setEmpID(2);
		Employee employee3 = new Employee();
		employee3.setEmpID(3);

		TreeSet set = new TreeSet();
		set.add(employee1);
		set.add(employee3);
		set.add(employee2);
		
		for(Object obj:set){
			Employee employee=(Employee)obj;
			System.out.println(employee.getEmpID());
		}
		System.out.println(set);
	}

}

Customized sorting of userdefined objects
-----------------------------------------
package com.manohar.java;
import java.util.Comparator;
import java.util.TreeSet;
class MyComparator implements Comparator{

	@Override
	public int compare(Object obj1, Object obj2) {
		Employee e1=(Employee)obj1;
		Employee e2=(Employee)obj2;
		return e2.compareTo(e1);
	}
}
public class EmpTest {
	public static void main(String[] args) {

		Employee employee1 = new Employee();
		employee1.setEmpID(1);
		Employee employee2 = new Employee();
		employee2.setEmpID(2);
		Employee employee3 = new Employee();
		employee3.setEmpID(3);

		TreeSet set = new TreeSet(new MyComparator());
		set.add(employee1);
		set.add(employee3);
		set.add(employee2);
		
		for(Object obj:set){
			Employee employee=(Employee)obj;
			System.out.println(employee.getEmpID());
		}
		System.out.println(set);

	}

}


write a program to sort employee objects according to employee name----------------------------------------
-------------




Queue[interface]
----------------
A queue inserts elements according to some priority and by default it follows a principle is First in First out[FIFO].

Properties
----------
dynamic
homogenous
insertion order is not preserved
duplicates are allowed
null is not possible in queue.

Method summary
--------------
  public abstract boolean add(E);
  adds an element to a queue.
 
  public abstract boolean offer(E);
  Adds an element to queue.

  public abstract Object remove();
  remove and retun object,if no element exist in queue   throws an exception java.util.NoSuchElementException

  public abstract Object poll();
  remove and return element,returns null if no element   exist in the queue.

  public abstract Object element();
  return first element,throws exception java.util.NoSuchElementException if no element exist in queue.
  
  public abstract Object peek();   
  return first element,returns null if no element exist in queue.

PriorityQueue
-------------
It is an impl class of Queue interface.

Introduced in 1.5 version of java.

Program
-------
package com.manohar.java;
import java.util.PriorityQueue;
public class QueueDemo {
	public static void main(String[] args) {
		PriorityQueue queue=new PriorityQueue();
		queue.offer(40);
		queue.offer(30);
		queue.offer(30);
		queue.offer(10);
		queue.offer(20);
		queue.offer(30);
		queue.add(40);
		//removal methods
		System.out.println(queue.remove());
		System.out.println(queue.poll());
		
		//examine elements
		System.out.println(queue.element());
		System.out.println(queue.element());
		System.out.println(queue);
	}	

}


Constructor summary
-------------------
PriorityQueue()
Creates a PriorityQueue with the default initial capacity (11) that orders its elements according to their natural ordering.

PriorityQueue(Collection<? extends E> c)
Creates a PriorityQueue containing the elements in the specified collection.

PriorityQueue(int initialCapacity)
Creates a PriorityQueue with the specified initial capacity that orders its elements according to their natural ordering.


PriorityQueue(int initialCapacity, Comparator<? super E> comparator)
Creates a PriorityQueue with the specified initial capacity that orders its elements according to the specified comparator.

PriorityQueue(PriorityQueue<? extends E> c)
Creates a PriorityQueue containing the elements in the specified priority queue.

PriorityQueue(SortedSet<? extends E> c)
Creates a PriorityQueue containing the elements in the specified sorted set.


Program
-------
package com.manohar.java;
import java.util.PriorityQueue;
public class QueueDemo {
	public static void main(String[] args) {
		PriorityQueue queue = new PriorityQueue();
		queue.add(10);
		queue.add(20);
		queue.add(50);
		queue.add(40);
		queue.add(70);
		queue.add(20);
		queue.add(50);
		queue.add(40);
		queue.offer(100);
		
		System.out.println(queue);

	
		//removal of elemements
		System.out.println(queue.remove());
	    System.out.println(queue.poll());
	    
	    //examining elements
	    System.out.println(queue.element());
	    System.out.println(queue.peek());
	    
		
		System.out.println(queue);

	}

}


Dequeue[double ended queue]
---------------------------
A deque is used to pefrom insert and delete operations from bothe the ends i,e rear and front end.Generally in a queue insertion is done through rear,deletion through front.

It is intorduced in 1.6 version.

It is a child interface of Queue

Method summary
--------------
 //addition if elements to dequeue
 public void addFirst(E);
 public void addLast(E);
 public boolean offerFirst(E);
 public boolean offerLast(E);

 //removal of elements from dequeue
 public  Object removeFirst();
 public  Object removeLast();
 public  Object pollFirst();
 public  Object pollLast();
 public  boolean removeFirstOccurrence(java.lang.Object);
 public  boolean removeLastOccurrence(java.lang.Object);

 //examining the elements of queue
 public abstract E getFirst();
 public abstract E getLast();
 public abstract E peekFirst();
 public abstract E peekLast();



Implementation classes
----------------------
A Deque has the following implementation classes.

1)ArrayDeque.
2)ConcurrentLinkedDeque. 
3)LinkedBlockingDeque.
4)LinkedList.

Program
-------
package com.manohar.java;
import java.util.LinkedList;
public class QueueTest {
public static void main(String[] args) {
	LinkedList list=new LinkedList();
	//addition of elements to dequeu
	list.add(10);
	list.add(20);
	list.add(30);
	list.addFirst(40);
	list.addLast(50);
	list.add(10);
	list.offerFirst(60);
	list.offerLast(70);
	list.add(10);
	System.out.println(list);
	
	//removal
	list.removeFirstOccurrence(10);
	System.out.println(list);
	list.removeLastOccurrence(10);
	list.removeLast();
	System.out.println(list);
	list.removeFirst();
	System.out.println(list);
	list.pollFirst();
	System.out.println(list);
	list.pollLast();
	System.out.println(list);
	
	//examine
	System.out.println(list.getFirst());
	System.out.println(list.getLast());
	System.out.println(list.peekFirst());
	System.out.println(list.peekLast());
	
	
}
}

output
------
[60, 40, 10, 20, 30, 50, 10, 70, 10]
[60, 40, 20, 30, 50, 10, 70, 10]
[60, 40, 20, 30, 50, 10]
[40, 20, 30, 50, 10]
[20, 30, 50, 10]
[20, 30, 50]
20
50
20
50






Map
---
Map is an interface available in java.util.* package.

Map is represents objects in the form of 
key-value pairs.

ex:
1--manohar
2--raghu
3--shekar
4--kvr
1--manohar

keys must be unique.
values can be duplicated.

Each key-value pair is called one entry.
                                  -----

Map Heirarchy
-------------
                      Map
                       |    
----------------------------------------------
^      |  ^              ^                   ^
|      |  |              |                   | 
HahsMap| LinkedHashMap  IdentityHashMap    SortedMap.
       |                                      ^
     WeakHashMap                              | 
                                           NavigableMap.
                                              ^
                                              |
                                            TreeMap.  

Note:Map and Collection are different heirachies.


Map is root interface of all Map's in java.

It is dynamic
 
It is used to represent group objects in the form of key and value pairs.

Methods of Map inteface
-----------------------
  public int size();
  returns size of Map.

  public boolean isEmpty();
  checks whether Map is empty or not.

  public boolean containsKey(java.lang.Object);
  checks whether a key is available in a map or not
returns true if available otherwise false.

  public boolean containsValue(java.lang.Object);
  checks whether a value is available in a map or not
  returns true if available otherwise false.

  public Object get(java.lang.Object);
  returns an a value of a key.

  public Object put(K, V);
  adds an entry to a Map.

  public Object remove(java.lang.Object);
  remove an object from a Map.


  public void putAll(java.util.Map<? extends K, ? extends V>);
  Add one Map to another Map.

  public  void clear();
  clears a Map.

  public  java.util.Set<K> keySet(); 
  returns Set of keys.

  public  java.util.Collection<V> values();
  returns collection values

 public  java.util.Set<java.util.Map$Entry<K, V>>  entrySet();
 returns all entries in the form of Set.

  public boolean equals(java.lang.Object);' 
  public int hashCode();

  public Object getOrDefault(java.lang.Object, V);
  returns a value of a key if it exists in a map otherwise   returns default value specified by developer.
  
  public boolean remove(java.lang.Object, 
  java.lang.Object);

  public boolean replace(K, V, V);
  public Object replace(K, V);
 


Map.Entry
---------
Entry is a inner interface of a Map.

A Map interface HAS-A Entry interface.

Entry provides methods to operate on an entry,it provides methods to read and update an entry in a Map.

syntax
------
interface Map
{
   interface Entry
    {
        public K getKey();
        //returns from entry
        public V getValue();
        //return value from entry
        public V setValue(V);
        //updates a value in entry

        public boolean equals(java.lang.Object);
        public int hashCode();
  }
}

HashMap
------- 
It is impl class of Map.

Introduced in  1.2 version of java.

Properties
----------
dynamic

Both keys and values are heterogenous.

Insertion order is not preserved because,objects are inserted into a Map based on HashCode of a keys.

keys must be unique,values can be duplicated.

null insertion is possible for both keys and values,but for keys null insertion is allowed only for one time.

underlying datastructure is Hashtable.


Constructor summary
-------------------
HashMap()
Creates an empty HashMap with the default initial capacity (16) and the default load factor (0.75).

HashMap(int initialCapacity)
Creates an empty HashMap with the specified initial capacity and the default load factor (0.75).


HashMap(int initialCapacity, float loadFactor)
Creates an empty HashMap with the specified initial capacity and load factor.


HashMap(Map<? extends K,? extends V> m)
Creates a new HashMap with the same mappings as the specified Map.

Program
-------
package com.manohar.java;
public class HashMapDemo {
public static void main(String[] args) {
	HashMap map=new HashMap();
	map.put(1,"manohar");
	map.put(2, "manohar");
	map.put(3, "manohar");
	map.put(4, "kvr");
	map.put(5, "venkatesh");
	map.put(null,"sunil");
	map.put(1,"sachin");
	
	System.out.println(map);
	
	System.out.println(map.size());//6
	System.out.println(map.isEmpty());//false
	System.out.println(map.containsKey(7));
	System.out.println(map.containsValue("manohar"));
	System.out.println(map.get(1));
	System.out.println(map.remove(null));
	System.out.println(map);
	
	
	Set set=map.keySet();
	System.out.println(set);
	
	Collection collection=map.values();
	System.out.println(collection);
	
	System.out.println(map.getOrDefault(4,"xyz"));
	
	System.out.println(map.replace(4,"kvr","manohar"));
	System.out.println(map.replace(1,"virat"));
	
	System.out.println(map);
	
}
}
Program
-------
package com.manohar.java;

import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Set;
public class HashMapDemo {
public static void main(String[] args) {
	HashMap map=new HashMap();
	map.put(10,"orange");
	map.put(2, "grapes");
	map.put(3, "apple");
	map.put(40, "pineapple");
	map.put(5, "mango");
	
	Set set=map.keySet();
	
	Iterator iterator=set.iterator();
	
	while(iterator.hasNext()){
		int x=(int)iterator.next();
		System.out.println(x+"  "+map.get(x));
	}

		
	System.out.println(map);

	
}
}


Program
-------
package com.manohar.java;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;
public class HashMapDemo1 {
	public static void main(String[] args) {
		HashMap map = new HashMap();
		map.put(1, "manohar");
		map.put(2, "raghu");
		map.put(3, "shekar");
		map.put(4, "kvr");
		map.put(5, "manohar");
		System.out.println(map);
		
	  Collection collection=map.values();
	  Set set=new HashSet(collection);
	  System.out.println(set);
		
			
}

}


Dictionary
^
|
Hashtable
^
|
Properties


Dictionary
----------
It  is used to represent data in the form of key and value pairs.

It is a legacy class introduced in 1.0 version.

It is an abstract class.


Hashtable
---------
It is a child of Dictionary and impl class of Map.

1.0 version.

Properties
----------
dynamic.
Insertion order is not preserved.
null values are not allowed for both keys and values.
keys must be unique,values can be duplicated.
both keys and values can be heterogenous.
underlying datatstructure Hashtable.
It is a synchronized class.
It is threadsafe
Performance wise it is poor.


constructor summary
-------------------
Hashtable()
Creates a new, empty hashtable with a default initial capacity (11) and load factor (0.75).


Hashtable(int initialCapacity)
Creates a new, empty hashtable with the specified initial capacity and default load factor (0.75).

Hashtable(int initialCapacity, float loadFactor)
Creates a new, empty hashtable with the specified initial capacity and the specified load factor.

Hashtable(Map<? extends K,? extends V> t)
Creates a new hashtable with the same mappings as the given Map.

Program
-------
package com.manohar.java;

import java.util.Hashtable;
public class HashTableDemo {
	public static void main(String[] args) {
		Hashtable hashtable=new Hashtable();
		hashtable.put(1,"samsung");
		hashtable.put(2,"iphone");
		hashtable.put("a",1);
		hashtable.put(3,"nokia");
		hashtable.put(4,"lg");
		hashtable.put(5,"lenovo");
		
		
		System.out.println(hashtable);
	}
}

}






Properties
----------
A properties class is used to perform operations on a properties file like read,write,update and delete operations.
 
A properties file is used to represent properties like database connection,language,location etc

Program
-------
package com.manohar.java;

import java.util.Hashtable;
import java.util.Properties;

public class HashTableDemo {
	public static void main(String[] args) {
		
		Properties  properties=new Properties();
		properties.put(1,"rambo");
		properties.put(2,"terminator");
		properties.put(3,"matrix");
		properties.put(4,"avengers");
		properties.put(5,"expendables");
		
		System.out.println(properties);
}

}



putAll()
--------
This is used to copy all the entries of one map to another map.


Program
-------
package com.manohar.java;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Properties;

public class HashTableDemo {
	public static void main(String[] args) {
		
		Properties  properties=new Properties();
		properties.put(1,"rambo");
		properties.put(2,"terminator");
		properties.put(3,"matrix");
		properties.put(4,"avengers");
		properties.put(5,"expendables");
		
		System.out.println(properties);
		
		HashMap map=new HashMap();
		map.putAll(properties);
		
		System.out.println(map);
		
	}

}


Collection
----------
addAll()
  Adds one collection to another collection.

removeAll()
  remove one collection from another collection.

retainAll()
retains(keeps) common elements between 2 collections and removes uncommon elements of a collection.

containsAll()
checks whether one collection exists in another collection or not


Program
-------
package com.manohar.java;

import java.util.ArrayList;

public class MethodsDemo {
	public static void main(String[] args) {
		ArrayList list=new ArrayList();
		 list.add("dog");
		 list.add("cat");
		 list.add("tiger");
		
		
		ArrayList list1=new ArrayList();
		 list1.add("rose");
		 list1.add("lilly");
		 list1.add("jasmine");
		
		 ArrayList list2=new ArrayList();
		 list2.add("rose");
		 list2.add("lilly");
		 list2.add("jasmine");
		 list2.add("sunflower");
		 list2.add("cauliflower");
		 
		
		 list2.retainAll(list1);
		 System.out.println(list2);
		
		 list2.addAll(list);
		 System.out.println(list2);
			
		 
		 System.out.println(list2.containsAll(list));
		 list2.removeAll(list);
		 System.out.println(list2.containsAll(list));
		 System.out.println(list2);
		 
}

}



Utility classes in Collection
-----------------------------
we have 2 utility classes in java.util.* package

i)Collections
ii)Arrays


Collections
-----------
Collections is a class which provides methods to perform operations on collections like sorting,searching,reversing etc.

Method summary
--------------
public static void sort(List list);
public static void sort(List list, Comparator c).
public static int binarySearch(List  list,Object key).
public static  void copy(List dest,List src);.
public static  Object max(Collection coll).
public static  Object min(Collection coll).
public static void reverse(List list).
public static Comparator reverseOrder(Comparator).

Program
-------
package com.manohar.java;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class CollectionsDemo {
	public static void main(String[] args) {

		List list = new ArrayList(10);

		list.add(10);
		list.add(20);
		list.add(5);
		list.add(15);
		list.add(9);

		System.out.println(list);
		List list2 = new ArrayList();
		list2.add(50);
		list2.add(60);
		list2.add(70);
		list2.add(50);
		list2.add(60);
		list2.add(70);

		Collections.copy(list2, list);
		System.out.println(list2);

Collections.sort(list2, Collections.reverseOrder());
		System.out.println(list2);

		Collections.sort(list);
		System.out.println(list);

		int key = 45;
		int res = Collections.binarySearch(list, key);
		System.out.println(res);

		Collections.reverse(list);
		System.out.println(list);

		System.out.println(Collections.max(list));
		System.out.println(Collections.min(list));
		
		
	}
}

Note:if we are using copy method make sure the size of destination list is having  bigger capacity than source list.

Note2:reverseOrder() method should be passed as a parameter to sort() method,sort() method will sort elements of List in ascending order,reverseOrder() will convert this ascending to descending.

Note3:while applying binary search make sure a List is sorted  in ascending order.

Arrays
------
Arrays is an utilty class applicable in primitive arrays to perform sorting,searching etc.

public static void sort(array);
public static int binarySearch(array,key);
public boolean equals(array1,array2);

Program
-------
package com.manohar.java;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

public class CollectionsDemo {
public static void main(String[] args) {

String s[] = { "samantha", "kajal", "rakul", "suresh", "rashi" };
String s2[] = { "samantha", "kajal", "rakul", "suresh", "rashi" };
System.out.println(Arrays.equals(s, s2));

for (String str : s)
System.out.print(str + ",");
System.out.println();
Arrays.sort(s);

for (String str : s)
System.out.println(str + ",");

int res = Arrays.binarySearch(s, "suresh");
System.out.println(res);
		
List list=Arrays.asList(s);
System.out.println(list);
		
}
}

Note:
asList() method converts array to List.


Methods to synchronize List,Set,Map
-----------------------------------
To get synchornized version of List,Set,Map,Collections class provides following methods.

i) public List  synchronizedList()
     returns synchronizedList of any List class.

ii)public Set synchronizedSet()
     returns synchronizedSet of any Set class.

iii)public Map synchronizedMap()
     returns synchronizedMap of any Map class.


ArrayList l=new ArrayList();
l.add(10);
l.add(20);
l.add(30);

List list=Collections.synchronizedList(l);

simliary Apply for Set and Map



Generics
--------
Collections are heterogenous

We should always apply casting.

code:
ArrayList list=new ArrayList();
list.add(10);
list.add(20);

int x=(int)list.get(0);

get() returns object,if we don't apply casting properly then it may lead ClassCastException.

Collection is not type safe.

Generic  Collection
-------------------
generics provide type safety.

type casting is not necessary.

generics provides compiletime checking.


Generic respresentation of collection
-------------------------------------
We declare a generic representation by using diamond(<>) operator with collection.

syntax
------
ClassName<type> referencename=new ClassName<type>();

we should pass type as only reference type as a parameter to a generic collection,primitive are not accepted as a parameter.

Program
-------
public class GenDemo {

public static void main(String[] args) {
ArrayList<Integer> list=new ArrayList<Integer>();
		
		list.add(10);
		list.add(20);
		list.add(30);
		list.add(40);
		list.add(50); 
		
		
		int x=list.get(0);//line1
		System.out.println(x);
		System.out.println(list);
		
	
}
}

In the above code we are getting value from ArrayList @line1 without applying any casting.


Generic respresentation of a Map
--------------------------------
ClassName<tyep1,type2> referencename=new ClassName<type1,type>();

Here we should represent type1 and type2 as class type or reference type.

Program
-------
public class GenDemo {
	public static void main(String[] args) {
	   HashMap<Integer,String> map=new HashMap<Integer,String>();
	   
	   map.put(1,"manohar");
	   map.put(2,"venkatesh");
	   map.put(3, "raghu");
	   map.put(4, "shekar");
	   map.put(5, "kvr");
	   
	   System.out.println(map);
	   
}

}



creating userdefined Generic class
----------------------------------
we should declare by using diamond operator with a classname shown in below.

syntax
------
accessmodifier class ClassName<E>
{


}

Here E is a generic type paramater which accepts any type of value like Integer,Float,Double,ClassType like Employee,Donkey,Monkey etc

we use the following standard names for parameter types

T - Type
E - Element
K - Key
N - Number
V - Value

Program
-------

class Test<T>
{
	T a;
	public void add(T a){
		this.a=a;
	}
	public T get(){
		return a;
	}
	
	
}
public class GenDemo {
	public static void main(String[] args) {
	   
		Test<Integer> t1=new Test<Integer>();
		t1.add(10);
		System.out.println(t1.get());
		
		Test<String> t2=new Test<String>();
		t2.add("how is it");
		System.out.println(t2.get());
		
		
		
	}

}


creating generic method 
-----------------------
A generic method will any type of value.The parameter to a generic methods must be of generic type as shown below.

syntax
------
accessmodifier <T> returntype methidname(T t)
{


}

Program
-------
public class GenDemo {
	
	public <T> void display(T t[]){
		for(T t1:t){
			System.out.println(t1);
		}
		
	}
	public static void main(String[] args) {
		Integer a[]={1,2,3,4,5};
		new GenDemo().display(a);
	}

}


Wild card characters in gererics 
--------------------------------
Special symbols used with Collections are called Wild card charcaters.

? is the wild card character applied with collections.

In generic code, the question mark (?), called the wildcard, represents an unknown type

syntax
------
<? extends ClassName>


Here ? repre














































































	












	





































































 


































































 




























 












































        










































































 











































































































































































 



























Strings
-------
i)A String is group of letters enclosed in double quotes.

"manohar"
"satya"

etc

we can represnt stringss using the following classes in java

i)String.
ii)StringBuffer.
iii)StringBuilder.

All the above classes are available in java.lang.* package.


String 
------
A String is a class in java.lang.* package.

we can use String class in 2 ways

i)declaring a String literal.
ii)Declaring a String object.

String literal
--------------
we can initialize string as a literal as shown below.

syntax
------
String s="kalam";

whenever we declare a String as a literal,the memory for String literal is allocated in a memory area called as String Constant pool.

when the above statement is exceuted jvm will create an object for String "s" and stores the literal in object as shown in diagram


String object
-------------
We can declare String as object,we are provided buit-in constructors to create String objects in number ways.

Constructors of String  class
-----------------------------
  public java.lang.String();
  public java.lang.String(java.lang.String);
  public java.lang.String(char[]);

  etc

we have 15 constructors in String class



syntax
------
String varname=new String();  
This creates an Empty String object.

or

String varname=new String(String);
This creates a String object with String as value.

ex:
String s=new String("java");

If the above statement executed jvm will allocate memory for the above in heap,also it will keep a copy of that in String Constant pool as shown in the diagram.


Internal representation of String
---------------------------------
String str="student";

whenever we declare a String,a String is stored into a character array.


String is immutable i,e we cannot modify the object of a String.

example
------
String s1="teacher";//line1
System.out.println(s1);//teacher

s1="student";//line2
System.out.println(s1);//student

In the above code when line1 is executed an object is created for String in String constant pool as shown below
---------
|teacher|------>s1
---------       100
 100

@line2 we are re-initializing s1 with student,here we are trying modify String s1,here jvm does't make any change to existing object but creates a new object in String constant pool and replaces the address of new object in the reference variable s1 as shown in the diagram.

How many objects are created for the following declarations.

String s1="Sathakarni";//1
String s2="Khaidino150";//2
String s3=""Sathakarni";;//3
String s4="SMB";//4

Analasys
--------
For the above 4 declarations 3 objects are created.

when line1 is executed jvm will create a new object in String constant poool as shown below.

Similarly jvm will create new objects for s2,s4,but for s3 jvm doesn't create a new object because if there is an object already existing in String constnat pool jvm doesn't create a new object  for that string but infact copies the address of existing to the reference variable of a new declaration.


Note:
Duplicate object's are not created in String constant pool.if we declare same string literal for multiple times,the object is created for this literal only for one time in scp and all the references share the address of same object.

How many objects are created for the following declarations.

String s1=new String("Java");
String s2=new String("Java");

Ans:3 objects


Analysis
--------
we had declared the above Strings as objects,for each declaration a new object is created in heap memory even if the string is same or different.

Altogether 3 objects are created,2 in heap and 1 in String constant pool as shown in the diagram.

Methods of String class
-----------------------
  public int length();
   returns length of a String.

  public boolean isEmpty();
  checks whether String is empty or not returns true   if it is empty otherwise false

  public char charAt(int);
  returns a character at a given index.
  Program
  -------
  class StringTest
  {
    public static void main(String args[])
    {
      String s1="shankar";
      System.out.println(s1.length());//7
      System.out.println(s1.isEmpty());//false
      System.out.println(s1.charAt(2));//a
   }
  }


  public boolean equals(java.lang.Object);

  It checks whether 2 strings are same or not,returns true if the strings are same otherwise false.

  public boolean equalsIgnoreCase(java.lang.String);
  It checks whether 2 strings are same or not ignoring case,returns true if the strings are same otherwise false.

Program
-------
class StringTest
{
  public static void main(String args[])
  {
      String s1="shankar";
      String s2="java";
      String s3="JAVA";    

       System.out.println(s1.equals(s2));//false
       System.out.println(s2.equals(s3));//false
       System.out.println(s2.equalsIgnoreCase(s3));//true
}
}

public int compareTo(java.lang.String);

compare 2 strings returns zero(0) if 2 strings are same otherwise returns unicode difference between 2 strings.

public int compareToIgnoreCase(java.lang.String);
compare 2 strings ignoring case, returns zero(0) if 2 strings are same otherwise returns unicode difference between 2 strings.

public boolean startsWith(java.lang.String, int);
checks starting part of a String from a given index.

public boolean startsWith(java.lang.String);
checks starting  of a String.

public boolean endsWith(java.lang.String);
checks ending part of a string.

public int indexOf(int);
returns indexOf a character in a string

public int lastIndexOf(int);
returns index of last occurance of a character in a String.

public int indexOf(java.lang.String);
returns index of String in a String array.

public java.lang.String substring(int);
returns a part of string starting from the given index.

public java.lang.String substring(int, int);
returns part of a string between the given range.

public java.lang.String concat(java.lang.String);
It is used to combine 2 strings

public java.lang.String replace(char, char);
replaces old character with new character

public java.lang.String[] split(java.lang.String, int);
It is used break a String into tokens by a given seperator.
public java.lang.String toLowerCase();
converts a string to lowercase.

public java.lang.String toUpperCase();
converts a string to uppercase

public java.lang.String trim();
removes spaces at the beginning and ending of a string.

Garbage Collection
------------------
It is a mechanism of removing unwanted objects from memory.

Garbage collection automatically performed in java.

Jvm uses a program called Garbage collector to perform Garbage collection.

we can also perform garbage collection explicitly or programmatically by using the method gc() available in System class.

An object is eligible for garbage collection only if it doesn't have any external reference.


gc()
---
It is a static method available in System class.

whenever we call gc(),it will make a call to garbage collector,but we cannot guarantee whether garbage collection will be perform or not, even though we make a call to garbage collector explicitly using gc(),it depends on mercy of jvm.

How to call gc() method
-----------------------
syntax
------
System.gc();

Finalization
------------
It is process of performing garbage collection before an object is eligible for garbage collection.

we use the method finalize to implement clean up operations on an object which is about to be garbage collected.

finalize() is a method available in Object class,we can override it in a sub class to as per requirement.

A finalize method is automatically called by garbage collector.

Program
-------
package com.manohar.java;
class Test1{
	void m1(){
		System.out.println("m1");
	}
	
	public void finalize(){
System.out.println("Hey good byee!!!Will meet you in next life");
	}
}
public class GarbageDemo {
	public static void main(String[] args) {
		Test1 t1=new Test1();
		Test1 t2=new Test1();
		Test1 t3=new Test1();
		
		t1.m1();
		t2.m1();
		t3.m1();
	
		t2=null;//1
		System.gc();//2
		
	}
}

In the above code @line1 the object t2 is eligible for garbage collection. 

@line2 we are explicitly making a call to  garbage collector using gc().


Excution flow of Garbage Collection
-----------------------------------
gc()-->Garbage collector-->finalize()


WeakHashMap
-----------
WeakHashMap is same as HashMap.


Whenever an object is associated with HashMap,it is not
eligible for garbage collection even though it doesn't have any external reference,here HashMap dominate garbage collector.

Program
-------
package com.manohar.java;
class Test1{
	public void finalize(){
		System.out.println("Hey good byee!!!Will meet you in next life");
	}
}
public class GarbageDemo {
	public static void main(String[] args) {
		Test1 t1=new Test1();
		Test1 t2=new Test1();
				
		HashMap  map=new HashMap();
		map.put(t1,"manohar");
		map.put(t2,"modi");
		System.out.println(map);
		
		t1=null;
		System.gc();
		
		System.out.println(map);
	}
}

output
------
{com.manohar.java.Test1@15db9742=manohar, com.manohar.java.Test1@6d06d69c=modi}

{com.manohar.java.Test1@15db9742=manohar, com.manohar.java.Test1@6d06d69c=modi}


Whenever an object is associated with WeakHashMap,it is 
eligible for garbage collection if  doesn't have any external reference,here  garbage collector dominates WeakHashMap.

Replace HashMap with WeakHashMap in the above code 

output
------
{com.manohar.java.Test1@15db9742=manohar, com.manohar.java.Test1@6d06d69c=modi}

{com.manohar.java.Test1@6d06d69c=modi}

Hey good byee!!!Will meet you in next life



final 
It is  a keyword declared with
variables.
methods.
classes.


finally
It is declared with either try/catch 
It is used to perform clean up operations.


finalize
It is a method which is declared in Object class,used to perform finalization.


IdentityHashMap
---------------
It is same as HashMap.

HashMap uses equals method to compare 2 keys and if the keys are same then it will replace old key with new key otherwise insert a key into HashMap according to hashcode of a key.

Program
-------
package com.manohar.java;
import java.util.HashMap;
import java.util.IdentityHashMap;
class Test4{
	
}
public class IdentityDemo {
	public static void main(String[] args) {
	    Integer integer1=new Integer(10);
	    Integer integer2=new Integer(10);
		
		HashMap map=new  HashMap();
		map.put(integer1,"manohar");
		map.put(integer2,"java");
		
		System.out.println(map);
		
	 }

}

output
------
{10=java}

IdentityHashMap uses == operator to compare 2 keys,if the  
keys are same then it will replace old key with new key otherwise insert a key into HashMap according to hashcode of a key.

In the above replace HashMap with IdentityHashMap.

output
------
{10=manohar, 10=java}

Note:
equals method in HashMap is overridden from Object class to perform content comparision of 2 keys.

we know that == operator always perform reference(address) comparision.

SortedMap(interface)
---------
It is  used to perform natural sorting of keys in Map.

1.2 version.

Method summary
--------------
 public abstract java.util.SortedMap<K, V> subMap(K, K);
 public abstract java.util.SortedMap<K, V> headMap(K);
 public abstract java.util.SortedMap<K, V> tailMap(K);
 public abstract K firstKey();
 public abstract K lastKey();
 public abstract java.util.Set<K> keySet();
 public abstract java.util.Collection<V> values();
 public abstract java.util.Set<java.util.Map$Entry<K, V>> entrySet()

NavigableMap(interface)
-----------------------
It provides certain navigational methods.

1.6 version.

Method summary
--------------
 public  Map$Entry<K, V> lowerEntry(K);
 public  K lowerKey(K);
 public  Map$Entry<K, V> floorEntry(K);
 public  K floorKey(K);
 public  Map$Entry<K, V> ceilingEntry(K);
 public  K ceilingKey(K);
 public  Map$Entry<K, V> higherEntry(K);
 public  K higherKey(K);
 public  Map$Entry<K, V> firstEntry();
 public  Map$Entry<K, V> lastEntry();
 public  Map$Entry<K, V> pollFirstEntry();
 public  Map$Entry<K, V> pollLastEntry();
 public  NavigableMap<K, V> descendingMap();


TreMap
------
It is an Impl class of Map,SortedMap,NavigableMap,Serializable,Cloneable.

TreeMap sorts entries according natural sorting order.

1.2 versiom

Properties
----------
dynamic

Keys must be homogenous,values can be duplicated.

insertion not preserved.

null insertion is not possible for keys,but allowed for values.

duplicates are not allowed for keys,values can be duplicated.

Underlying datastructure is Red-black tree.


Program
-------
package com.manohar.java;

import java.util.TreeMap;

public class TreeMapDemo {
	public static void main(String[] args) {
		TreeMap map=new TreeMap();
		map.put(2,"3idiots");
		map.put(1,"harrypotter");
		map.put(3,"you can win");
		map.put(4,"halfgirlfriend");
		map.put(5,"7 habits");
		map.put(6,"Think and grow rich");
		map.put(7,"Alchemist");
		
		System.out.println(map);
		//sorted Map methods
		System.out.println(map.subMap(2, 5));
		System.out.println(map.headMap(4));
		System.out.println(map.tailMap(5));
		System.out.println(map.firstKey());
		System.out.println(map.lastKey());
		
		//Navigable Map methods
		System.out.println(map.floorKey(3));
		System.out.println(map.floorEntry(5));
		System.out.println(map.ceilingKey(4));
		System.out.println(map.ceilingEntry(4));
		System.out.println(map.lowerKey(3));
		System.out.println(map.higherKey(6));
		System.out.println(map.pollFirstEntry());
		System.out.println(map.pollLastEntry());
		
		System.out.println(map);
}

}

StringTokenizer
---------------
It is used divide a string into tokens
It is available java.util.*.
It impl class of Enumeration.


construtor summary
------------------
public java.util.StringTokenizer(java.lang.String,  java.lang.String)
Accepts String and seperator as parameters  

public java.util.StringTokenizer(java.lang.String);
Accepts a String as a parameter.

Note:The default seperator is space.

Method summary
--------------
public boolean hasMoreTokens();
returns if a string is available in a string array otherwise return false.

public java.lang.String nextToken();
Moves to cursor to next string and returns that String.

public boolean hasMoreElements();
public java.lang.Object nextElement();


public int countTokens();
counts the no of tokens in a string.

Note:
StringTokenizer is an implementation class of Enumeration interface.

package com.manohar.java;

import java.util.StringTokenizer;
public class StringTokenizerDemo {
public static void main(String[] args) {
String str="Teaching is energy of my life";
StringTokenizer  tokenizer=new StringTokenizer(str, " ");
System.out.println(tokenizer.countTokens());

while(tokenizer.hasMoreTokens()){
System.out.println(tokenizer.nextToken());
}
}
}

Program
-------
package com.manohar.java;

import java.util.StringTokenizer;

public class StringTokenizerDemo {
	public static void main(String[] args) {
		String str="Teaching is energy of my life";
		StringTokenizer  tokenizer=new StringTokenizer(str, " ");
		
		//string array
		String s[]=new String[tokenizer.countTokens()];
		
		int i=0;
		while(tokenizer.hasMoreTokens()){
			
			s[i]=tokenizer.nextToken();
			System.out.println(s[i]);
			i++;
		}
		
		for(i=0;i<s.length;i++){
			
			System.out.println(s[i]);
		}
	}

}

Files in java[streams]
----------------------
A stream is flow of bits.

Streams are used to perform following operations on files

i)Opening a file.
ii)writing into a file.
iii)reading from a file.
iv)appending a file.
v)closing a file.


There are 2 types of streams.They are 
i)character streams.
ii)byte streams.


Charcter streams
----------------
A character is used to perform operations on character type of data in a file.

An unicode encoding is applied on character streams.

A character stream is used to perform read and write operation on a file by using following classes in java.io.* package.


i)Reader.
ii)Writer.

Writer 
------
It is super class of all writer classes in io package.

It is an abstract class.

It is used to perform write operation on a file.

Methods
-------
public void write(xxxx);
public Writer append(xxxx);
public abstract void flush();
public abstarct void close();

A Writer has the following subclasses.

Writer
|                               
BufferedWriter    
CharArrayWriter   
FileWriter             
PrintWriter

FileWriter
----------
It is subclass of OutputStreamWriter.

It is used to write data into a character file.

constructor summary
-------------------
FileWriter(File file)
Creates a FileWriter object given a File object.

FileWriter(File file, boolean append)
Constructs a FileWriter object given a File object.

FileWriter(FileDescriptor fd)
Constructs a FileWriter object associated with a file descriptor.

FileWriter(String fileName)
Constructs a FileWriter object given a file name.

FileWriter(String fileName, boolean append)
Constructs a FileWriter object with a given a file name with a boolean indicating whether  to append the data to a file or not.

Steps to perform write operation on a file
------------------------------------------
step1:create object for a FileWriter class and pass the name of the file.

FileWriter out=new FileWriter("file path");
ex:
FileWriter out=new FileWriter("d:\\abc.txt");


Here the file is open in write mode i,e if we open a file in write mode then every time the previous data of a file is removed and new data is overwritten.


FileWriter out=new FileWriter("file path",true);

Here the file is open in append mode i,e if we open a file in append mode then data is added to the already existing file without any overwriting.



step2:write data to a file.

syntax
------
out.write(data);

ex:
out.write(10);


step3:closing a file

syntax
------
out.close();

Note:
write(),flush(),close(),FileWriter() throws IOEXception.



Reader
------
A Reader performs read operation on a file.

It is super class of all Reader classes in java.io.* package.

Reader class consists of the following sub classes
BufferedReader, 
CharArrayReader, 
FilterReader, 
InputStreamReader, 
PipedReader,
StringReader.

Method summary
--------------
public int read(xxx);
public void close();


FileReader
----------
It is a sub class of InputStreamReader

It is used to perform read operation on a file

Constructor summary
-------------------
public java.io.FileReader(java.lang.String) throws java.io.FileNotFoundException;

public java.io.FileReader(java.io.File) throws java.io.FileNotFoundException
 
public java.io.FileReader(java.io.FileDescriptor);

steps to perform read operation on a file
-----------------------------------------
step1:create an object for FileReader() and open a file.

syntax
------
FileReader in=new FileReader("file path");

ex:
FileReader in=new FileReader("d:\\abc.txt");

step2:read data from a file using read()

syntax
------
in.read();

step3:close the file.
in.close();


Program
-------
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

public class FileDemo {
	public static void main(String[] args) throws IOException {

		/*
		 * FileWriter out=new FileWriter("abc.txt"); for(int i=1;i<=10;i++){
		 * out.write(i);
		 * 
		 * } out.close(); System.out.println("done");
		 */

		FileReader in = new FileReader("abc.txt");
		FileWriter out = new FileWriter("xyz.txt");

		int x;
		while ((x = in.read()) != -1) {
			out.write(x);
		}
		in.close();
		out.close();

		FileReader in2 = new FileReader("xyz.txt");
		int x1;
		while ((x1 = in2.read()) != -1) {
			System.out.println(x1);
		}
		in2.close();
		System.out.println("success");

	}

}



Byte Streams
------------
Byte streams performs operation on binary data(numeric)

Byte streams doesn't have any encoding like character streams.

Byte streams 2 super classes 

Inputstream
OutStream

InputStream
-----------
It is a used to perform read operation on a binary file.

It is super class of all InputStream classes in io package.

It is an abstract class.

Method summary
--------------
public int read() 
public void close()

Here read and close throws IOException.

InputStream has the following subclasses

AudioInputStream, 
ByteArrayInputStream, 
FileInputStream, 
FilterInputStream,
InputStream, 
ObjectInputStream, 
PipedInputStream, 
SequenceInputStream, 
StringBufferInputStream


OutputStream
------------
It is used to perform write operation on a binary file.

It is super class of all OutStream classes in java.io.* package.

It is abstract class.


Method summary
--------------
public abstract void write(int) throws java.io.IOException;

public void write(byte[]) throws java.io.IOException;

public void write(byte[], int, int) throws java.io.IOException

public void flush() throws java.io.IOException;
public void close() throws java.io.IOException;


We use FileOutputStream and FileInputStream to perform write and operations on a file.
en

Serialization and deserialization
---------------------------------
If we want to write an object to a file,then the class of that object must be serializable and this process is known as Serialization.


steps to implement serialization
--------------------------------
step1:Implement Serialiazable interface in a class.

syntax
------
accessmodifier class ClassName implements Serializable
{
//   
}

step2:create object and set data.


step3:write object to file
Here we to have to 2 classes 
i)FileOutputStream
ii)ObjectOutputStream

FileOutputStream opens a file in write mode.

syntax
------
FileOutputStream out=new FileOutputStrem("filePath");

ex:
FileOutputStream out=new FileOutputStrem("d:\\employee.txt");

ObjectOutputStream
------------------
This is used to write an object to a file.

syntax
------
ObjectOutputStream out=new ObjectOutputStrem(OutputStream);

ex:
ObjectOutputStream oos=new ObjectOutputStrem(Out);

we use the method writeObject() to write an object to a file.

Method signature
----------------
public final void writeObject(Object) throws IOException

ex:
oos.writeObject(object);

Program
-------
Employee.java

public class Employee implements Serializable {
	private String name;
	private int empID;
	private double empSal;

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public int getEmpID() {
		return empID;
	}

	public void setEmpID(int empID) {
		this.empID = empID;
	}

	public double getEmpSal() {
		return empSal;
	}

	public void setEmpSal(double empSal) {
		this.empSal = empSal;
	}

}


SerializeDemo.java
------------------
package com.manohar.java;

import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;

public class SerializableDemo {
	public static void main(String[] args) throws IOException {
		// creating object for pojo
		Employee employee = new Employee();
		employee.setEmpID(1001);
		employee.setName("Manohar");
		employee.setEmpSal(2000.00);

		// open a file
		FileOutputStream out = new FileOutputStream("d:\\employee.txt");
		// create object for oos
		ObjectOutputStream oos = new ObjectOutputStream(out);

		// write object to file
		oos.writeObject(employee);

		oos.close();
		out.close();

	}

}

Note:
if we don't serialize and write an object to a file then it leads to NotSerializableException.

Deserialzation
--------------
The process of bringing back an object from a file to its original form is known as Deserialization.

Here we use 2 classes
i)FileInputStream
ii)ObjectInputStream

step1:
open a file in read mode to read an object.

FileInputStream in=new FileInputStream("file path");

ex:
FileInputStream in=new FileInputStream("d:\\employee.txt");

step2:ObjectInputStream is used to read an object from a file.

we use the readObject() to read an object from a file.

syntax
------
ObjectInputStream  ois=new  ObjectInputStream(InputStream);

ex:
ObjectInputStream  ois=new  ObjectInputStream(in);

How to read object from file
----------------------------
syntax
------
ClassName referenceName=(ClassName)ois.readObject();


Method signature
----------------
public Object readObject() throws ClassNotFoundException;

Note:
Here readObject() method returns Object we have to cast it to required class.

Program
-------
package com.manohar.java;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;

public class SerializableDemo {
	public static void main(String[] args) throws IOException, ClassNotFoundException {
		// open a file
		FileInputStream fis = new FileInputStream("d:\\employee.txt");
		// create object for oos
		ObjectInputStream ois = new ObjectInputStream(fis);

		// write object to file
		Employee employee=(Employee) ois.readObject();
		System.out.println(employee.getEmpID());
		System.out.println(employee.getName());
		System.out.println(employee.getEmpSal());
		
		ois.close();
		fis.close();

	}

}

transient keyword
-----------------
It is a keyword declared with only variables.

A transient keyword doesn't allow the property of a pojo/class to participate in Serializtion,here the actual value is replaced with default values.

transient keyword provides security to data while submitting data through a network or writing to a file.

syntax
------
accessmodifier transient datatype varname;

ex:
private transient int empID;

In the above code declare the properties of Employee as transient as shown below

public class Employee implements Serializable {
	private transient String name;
	private transient int empID;
	private transient double empSal;
      
        //setter and getter
}


Apply serialization and Deserialization


Output
------
null
0
0.0

File
----
File class is used to perform operations like creating a new file,new directory etc.

  
public boolean exists();
checks whether a file exists or not return true if available otherwise false.
  
public boolean isDirectory();
checks whether an is directory or not.

public boolean isFile();
checks whether an is file or not.

public long lastModified();

public long length();
returns length of a file.

public boolean createNewFile() throws java.io.IOExceptio
creates a new file.

public boolean delete();
delete a file or directory

public void deleteOnExit();
delete if file or directory exist

public java.lang.String[] list();
list all the files

public java.io.File[] listFiles();
returns all the files and folders of a drive.

public boolean mkdir();
make a directory
  
public String getName();
returns name of a file or directory.


Constructors of File 
--------------------
File(File dir, String path)
creates a new directory and puts a sub dir or file into it.

Here dir must exist

File(String pathname)
Accepts a filename as a parameter

File(String dir, String path)
copies a file/dir into an existing parent directory.

File(URI uri)
Creates a new File instance by converting the given file: URI into an abstract pathname.



Program
-------
package com.manohar.javamo;
import java.io.File;
import java.io.IOException;
public class FileDemo {
public static void main(String[] args) throws IOException {
		
//create
File  file=new File("d:\\fruits.txt");
		
if(file.exists()){
System.out.println("You jaffa already file exits!!!");
}
else{
boolean status=file.createNewFile();
if(status){
System.out.println("Hurray file is created");
}
else{
System.out.println("oops!!! file not created");
}
}

Program
-------
package com.manohar.javamo;

import java.io.File;
import java.io.IOException;

public class FileDemo {
	public static void main(String[] args) throws IOException {
		
//create a new dir
File  file=new File("d:\\datafiles");
		
if(file.exists()){
System.out.println("You jaffa already directory exits!!!");
}
else{
boolean status=file.mkdir();
if(status){
System.out.println("Hurray directory is created");
}
else{
System.out.println("oops!!! dir not created");
}
}
		
File  file2=new File("d:\\datafiles","abc.txt");
		
if(file2.createNewFile())
{
System.out.println("file created");
}
else{
System.out.println("Bullshit some thingwent wrong");
}
		
}

}


listing all the files from a directory
--------------------------------------
we can display all the files from a directory using list() method available in File class.


Code:
package com.manohar.javamo;

import java.io.File;
import java.io.IOException;
public class FileDemo {
public static void main(String[] args) throws IOException {
		
File file=new File("d:\\songs");
		
String s[]=file.list();
		
for(String str:s){
System.out.println(str);
}
}
}

Program
-------
package com.manohar.javamo;

import java.io.File;
import java.io.IOException;

public class FileDemo {
	public static void main(String[] args) throws IOException {

File file = new File("d:\\test");

File f[] = file.listFiles();

for (File f1 : f) {

if (f1.isFile()) {

String str=f1.getName();

if (str.startsWith("A") || str.startsWith("E") || str.startsWith("I") || str.startsWith("O")
||str.startsWith("U") ||str.startsWith("a")|| str.startsWith("u") || str.startsWith("o") || str.startsWith("i")|| str.startsWith("e")) {
if(f1.delete()){
System.out.println("file deleted");
}
}
}
}
}

}
























		
		
		
     
     
     
		
		
		

































	





























































































































 





























  
















































 








































































































































































































 
















 
































             















































































































































































































 







































































 



 






























































































 














































































































































































 


























































































































































































































































































































































                   























































































































































 






















































































































































































































































































































































































































































 






















































































































































 





































































































































































 













































































































































































































































































































































































 
  
























































































































  
























































































































































































































 
       




































































































































































































































































































































      







































      













































      


















































































































 





























































































        











































        

          












































































  






















































         
















































































































































































































































































































































































































































































































































































































scopes in java
--------------
There are 3 scopes in java.They are 
i)instance scope/object scope
ii)static scope/class scope
iii)methods scope/local scope



instance scope
--------------
Members which are part of object are said to be in instance scope

Instance variable
Instance methods 
Instance blocks

The above members are part of object,we can work with these members only by creating object otherwise it is not possible.


static scope
------------
Members which are part of class are said to be in static scope also we can say that as class scope,these members are not part of object and we dont need to create object to access static members.

we can directly access static members using ClassName.

static variable
static methods 
static blocks

are part of class.


method scope
------------
Members part of method are said to be in method scope i,e 

local variables
local blocks

local memebers are visible within that block itself.

























































































































































 













































































































































































































































































































































  
































  






































































































































 









































  

 
















































































































































































































































































































































































































 















































































































































































































































































































































 




























































































































  


























































































































































































































































































































































































































































































































































































 
















































   


































































   


































 
   







































































































































































































































 






























  
     





























































































































































































   
















  








































 
































































































































  
 
























































































































































































































































































































      


















































































































 






































































 







































































































































































































































































 























































  








     

    

   


 



































     

    

   


 





 





















































































 















































 











 
   
   



















































































































 















































 




















   




















































 

























































































































































































































































































































 
 
  

























































































































































































































































































































  
























































































































































































































 






















    
 













































   




















































 




































































 











































































































































































































































































































     
  
     




























  
   

































































































































































































































 


     
































































   









  















































































 












































































































































































  

 





































































































































































































  
      


























 























































































 






















































































































































































































